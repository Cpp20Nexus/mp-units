{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mp-units!","text":"<p>mp-units is a compile-time enabled feature-rich Modern C++ header-only library that provides compile-time dimensional analysis and unit/quantity manipulation. Its key strengths include safety, performance, and developer experience.</p> <p>The library source code is hosted on GitHub with a permissive MIT license.</p> <p>Help needed!</p> <p>The mp-units library might be the subject of ISO standardization for C++29. More on this can be found in the ISO C++ proposal P1935. We are actively looking for parties interested in field-trialing the library.</p> Supported compilers <p>This library tries to provide the best user experience possible with the C++ language. To achieve that, it extensively uses C++20 features and the explicit object parameter from C++23.</p> <p>Even though the library benefits from C++23 (if available), C++20 is enough to compile and use all of the library's functionality. C++23 features are hidden behind a preprocessor macro providing a backward-compatible way to use it.</p> <p>Sadly, as of today, only a few compilers provide full C++20 support. The library compiles fine on the following compilers (or newer):</p> <ul> <li>gcc-12.2</li> </ul> <p>In the upcoming weeks, we will be actively working to extend the support to other compilers as well.</p>"},{"location":"appendix/glossary/","title":"Glossary","text":""},{"location":"appendix/glossary/#iso-definitions","title":"ISO definitions","text":"<p>Note</p> <p>The ISO terms provided below are only a few of many defined in the ISO/IEC Guide 99.</p> <code>quantity</code> <ul> <li>Property of a phenomenon, body, or substance, where the property has a magnitude that can   be expressed by means of a number and a reference.</li> <li>A reference can be a measurement unit, a measurement procedure, a reference material,   or a combination of such.</li> <li>A quantity as defined here is a scalar. However, a vector or a tensor, the components of   which are quantities, is also considered to be a quantity.</li> <li>The concept \u2019quantity\u2019 may be generically divided into, e.g. \u2018physical quantity\u2019,   \u2018chemical quantity\u2019, and \u2018biological quantity\u2019, or \u2018base quantity\u2019   and \u2018derived quantity\u2019.</li> <li>Examples of quantities are: length, radius, wavelength, energy, electric charge, etc.</li> </ul> <code>kind of quantity, kind</code> <ul> <li>Aspect common to mutually comparable quantities.</li> <li>The division of the concept \u2018quantity\u2019 into several kinds is to some extent arbitrary, for example:<ul> <li>the quantities diameter, circumference, and wavelength are generally considered   to be quantities of the same kind, namely, of the kind of quantity called length,</li> <li>the quantities heat, kinetic energy, and potential energy are generally considered   to be quantities of the same kind, namely of the kind of quantity called energy.</li> </ul> </li> <li>Quantities of the same kind within a given system of quantities   have the same quantity dimension. However, quantities   of the same dimension are not necessarily of the same kind.<ul> <li>For example, the quantities moment of force and energy are, by convention, not regarded   as being of the same kind, although they have the same dimension. Similarly for   heat capacity and entropy, as well as for number of entities, relative permeability,   and mass fraction.</li> </ul> </li> </ul> <code>system of quantities</code> <ul> <li>Set of quantities together with a set of non-contradictory equations   relating those quantities.</li> <li>Examples of systems of quantities are: the International System of Quantities,   the Imperial System, etc.</li> </ul> <code>base quantity</code> <ul> <li>Quantity in a conventionally chosen subset of a given   system of quantities, where no quantity in the   subset can be expressed in terms of the others.</li> <li>Base quantities are referred to as being mutually independent since a base quantity   cannot be expressed as a product of powers of the other base quantities.</li> <li>\u2018Number of entities\u2019 can be regarded as a base quantity in any   system of quantities.</li> </ul> <code>derived quantity</code> <ul> <li>Quantity, in a system of quantities, defined in   terms of the base quantities of that system.</li> </ul> <code>International System of Quantities, ISQ</code> <ul> <li>System of quantities based on the seven base quantities:   length, mass, time, electric current, thermodynamic temperature, amount of substance,   and luminous intensity.</li> <li>This system of quantities is published in the ISO 80000 and IEC 80000 series Quantities and units.</li> <li>The International System of Units (SI) is based on the ISQ.</li> </ul> <code>quantity dimension, dimension of a quantity, dimension</code> <ul> <li>Expression of the dependence of a quantity on the base quantities   of a system of quantities as a product of powers of factors corresponding   to the base quantities, omitting any numerical factor.<ul> <li>i.e. in the ISQ, the quantity dimension of force is denoted by \\(\\textsf{dim }F = \\mathsf{LMT}^{\u20132}\\).</li> </ul> </li> <li>A power of a factor is the factor raised to an exponent. Each factor is the dimension   of a base quantity.</li> <li>In deriving the dimension of a quantity, no account is taken of its scalar, vector, or   tensor character.</li> <li>In a given system of quantities:<ul> <li>quantities of the same kind have the same quantity dimension,</li> <li>quantities of different quantity dimensions are always of different kinds,</li> <li>quantities having the same quantity dimension are not necessarily of the same   kind.</li> </ul> </li> <li> <p>Symbols representing the dimensions of the base quantities in the ISQ are:</p> Base quantity Symbol for dimension length \\(\\mathsf{L}\\) mass \\(\\mathsf{M}\\) time \\(\\mathsf{T}\\) electric current \\(\\mathsf{I}\\) thermodynamic temperature \\(\\mathsf{\u0398}\\) amount of substance \\(\\mathsf{N}\\) luminous intensity \\(\\mathsf{J}\\) <p>Thus, the dimension of a quantity \\(Q\\) is denoted by \\(\\textsf{dim }Q = \\mathsf{L}^\u03b1\\mathsf{M}^\u03b2\\mathsf{T}^\u03b3\\mathsf{I}^\u03b4\\mathsf{\u0398}^\u03b5\\mathsf{N}^\u03b6\\mathsf{J}^\u03b7\\) where the exponents, named dimensional exponents, are positive, negative, or zero.</p> </li> </ul> <code>quantity of dimension one, dimensionless quantity</code> <ul> <li>quantity for which all the exponents of the factors corresponding to the     base quantities in its quantity dimension are zero.</li> <li>The term \u201cdimensionless quantity\u201d is commonly used and is kept here for historical     reasons. It stems from the fact that all exponents are zero in the symbolic     representation of the dimension for such quantities.     The term \u201cquantity of dimension one\u201d reflects the convention in which the symbolic     representation of the dimension for such quantities is     the symbol <code>1</code>.</li> <li>The measurement units and values of quantities of     dimension one are numbers, but such quantities convey more information than a number.</li> <li>Some quantities of dimension one are defined as the ratios of two     quantities of the same kind.</li> <li>Numbers of entities are quantities of dimension one.</li> </ul> <code>measurement unit, unit of measurement, unit</code> <ul> <li>Real scalar quantity, defined and adopted by convention, with which any other   quantity of the same kind can be compared to express the ratio of the two   quantities as a number.</li> <li>Measurement units are designated by conventionally assigned names and symbols.</li> <li>Measurement units of quantities of the same quantity dimension   may be designated by the same name and symbol even when the quantities are   not of the same <code>kind</code>.<ul> <li>For example, joule per kelvin and J/K are respectively the name and symbol of both a   measurement unit of heat capacity and a measurement unit of entropy, which are generally   not considered to be quantities of the same kind. However, in some cases special   measurement unit names are restricted to be used with quantities of specific   kind only. For example, the measurement unit \u2018second to the power minus one\u2019   (1/s) is called hertz (Hz) when used for frequencies and becquerel (Bq) when used for   activities of radionuclides. As another example, the joule (J) is used as a unit of   energy, but never as a unit of moment of force, i.e. the newton metre (N\u00b7m).</li> </ul> </li> <li>Measurement units of quantities of dimension one are   numbers. In some cases, these measurement units are given special names, e.g. radian,   steradian, and decibel, or are expressed by quotients such as millimole per mole equal   to \\(10^{\u22123}\\) and microgram per kilogram equal to \\(10^{\u22129}\\).</li> </ul> <code>base unit</code> <ul> <li>Measurement unit that is adopted by convention for a base quantity.</li> <li>In each coherent system of units, there is only one base unit   for each base quantity.<ul> <li>i.e. in the SI, the metre is the base unit of length. In the CGS systems,   the centimetre is the base unit of length.</li> </ul> </li> <li>A base unit may also serve for a derived quantity of the same   quantity dimension.</li> <li>For number of entities, the number one, symbol <code>1</code>, can be regarded as a base unit in   any system of units.</li> </ul> <code>derived unit</code> <ul> <li>Measurement unit for a derived quantity.</li> <li>For example, the metre per second, symbol m/s, and the centimetre per second, symbol cm/s,   are derived units of speed in the SI. The kilometre per hour, symbol km/h, is a   measurement unit of speed outside the SI but accepted for use with   the SI. The knot, equal to one nautical mile per hour, is a measurement unit of speed   outside the SI.</li> </ul> <code>coherent derived unit</code> <ul> <li>Derived unit that, for a given system of quantities   and for a chosen set of base units, is a product of powers of   base units with no other proportionality factor than one.</li> <li>A power of a base unit is the base unit raised to an exponent.</li> <li>Coherence can be determined only with respect to a particular   system of quantities and a given set of base units.<ul> <li>For example, if the metre, the second, and the mole are base units, the metre per second is   the coherent derived unit of velocity when velocity is defined by the   quantity equation \\(v = \\mathsf{d}r/\\mathsf{d}t\\), and the mole per   cubic metre is the coherent derived unit of amount-of-substance concentration when   amount-of-substance concentration is defined by the quantity equation \\(c = n/V\\). The kilometre per hour and the knot, given as examples of derived units,   are not coherent derived units in such a system of quantities.</li> </ul> </li> <li>A derived unit can be coherent with respect to one   system of quantities but not to another.<ul> <li>For example, the centimetre per second is the coherent derived unit of speed in a CGS system   of units but is not a coherent derived unit in the SI.</li> </ul> </li> <li>The coherent derived unit for every derived quantity of dimension one   in a given system of units is the number one, symbol <code>1</code>. The name and   symbol of the measurement unit one are generally not indicated.</li> </ul> <code>system of units</code> <ul> <li>Set of base units and derived units, together with   their multiples and submultiples, defined in accordance with given rules, for a given   system of quantities.</li> </ul> <code>coherent system of units</code> <ul> <li>System of units, based on a given system of quantities,   in which the measurement unit for each derived quantity is   a coherent derived unit.</li> <li>A system of units can be coherent only with respect to a   system of quantities and the adopted base units.</li> <li>For a coherent system of units, numerical value equations have   the same form, including numerical factors, as the corresponding   quantity equations.</li> </ul> <code>off-system measurement unit, off-system unit</code> <ul> <li>Measurement unit that does not belong to a given system of units.</li> <li>For example, the electronvolt (about \\(1.602\\;18 \u00d7 10^{\u201319} \\mathsf{J}\\)) is an   off-system measurement unit of energy with respect to the SI. Day, hour, minute   are off-system measurement units of time with respect to the SI.</li> </ul> <code>International System of Units, SI</code> <ul> <li>System of units, based on the International System of Quantities,   their names and symbols, including a series of prefixes and their names and symbols,   together with rules for their use, adopted by the General Conference on Weights and   Measures (CGPM).</li> </ul> <code>quantity value, value of a quantity, value</code> <ul> <li>Number and reference together expressing magnitude of a quantity.</li> <li>The number can be complex.</li> <li>A quantity value can be presented in more than one way.</li> <li>In the case of vector or tensor quantities, each component has a quantity value.<ul> <li>For example, force acting on a given particle, e.g. in Cartesian components   \\((F_x; F_y; F_z) = (\u221231.5; 43.2; 17.0)\\;\\mathsf{N}\\).</li> </ul> </li> </ul> <code>quantity equation</code> <ul> <li>Mathematical relation between quantities in a given system of quantities,   independent of measure\u00adment units.</li> <li>For example, \\(T = (1/2) mv^2\\) where \\(T\\) is the kinetic energy and \\(v\\) the speed   of a specified particle of mass \\(m\\).</li> </ul> <code>unit equation</code> <ul> <li>Mathematical relation between base units,   coher\u00adent derived units or other measurement units.</li> <li>For example, \\(\\mathsf{J} := \\mathsf{kg}\\:\\mathsf{m}^2/\\mathsf{s}^2\\), where, \\(\\mathsf{J}\\),   \\(\\mathsf{kg}\\), \\(\\mathsf{m}\\), and \\(\\mathsf{s}\\) are the symbols for the joule, kilogram,   metre, and second, respectively. (The symbol \\(:=\\) denotes \u201cis by definition equal to\u201d   as given in the ISO 80000 and IEC 80000 series.). \\(1\\;\\mathsf{km/h} = (1/3.6)\\;\\mathsf{m/s}\\).</li> </ul> <code>numerical value equation, numerical quantity value equation</code> <ul> <li>Mathematical relation between numerical quantity values, based on   a given quantity equation and specified measurement units.</li> <li>For example, in the quantity equation for kinetic energy of a particle,   \\(T = (1/2) mv^2\\), if \\(m = 2 kg\\) and \\(v = 3 m/s\\), then \\({T} = (1/2) \u00d7 2 \u00d7 3^2\\) is a numerical   value equation giving the numerical value \\(9\\) of \\(T\\) in joules.</li> </ul>"},{"location":"appendix/glossary/#other-definitions","title":"Other definitions","text":"<p>Info</p> <p>The below terms extend the official ISO glossary and are commonly referred to by the mp-units library.</p> <code>base dimension</code> <ul> <li>A dimension of a base quantity.</li> </ul> <code>derived dimension</code> <ul> <li>A dimension of a derived quantity.</li> <li>Implemented as an expression template being the result of the   dimension equation on base dimensions.</li> </ul> <code>dimension equation</code> <ul> <li>Mathematical relation between dimensions in a given   system of quantities, independent of measure\u00adment units.</li> </ul> <code>quantity kind hierarchy, quantity hierarchy</code> <ul> <li>Quantities of the same kind form a hierarchy that determines their:<ul> <li>convertibility (i.e. every width is a length, but width should not be   convertible to height)</li> <li>common quantity type (i.e. width + height -&gt; length)</li> </ul> </li> </ul> <code>quantity character, character of a quantity, character</code> <ul> <li>Scalars, vectors and tensors are mathematical objects that can be used to denote   certain physical quantities and their values.   They are as such independent of the particular choice of a coordinate system,   whereas each scalar component of a vector or a tensor and each component vector   and component tensor depend on that choice.</li> <li>A vector is a tensor of the first order and a scalar is a tensor of order zero.</li> <li>For vectors and tensors, the components are quantities that can be   expressed as a product of a number and a unit.</li> <li>Vectors and tensors can also be expressed as a numerical value vector or tensor,   respectively, multiplied by a unit.</li> <li>Quantities of different characters support different set of operations.<ul> <li>For example, a quantity can be multiplied by another one only if any   of them has scalar character. Vectors and tensors can't be multiplied or divided,   but they support additional operations like dot and cross products, which   are not available for scalars.</li> </ul> </li> <li>The term \u2019character\u2019 was borrowed from the below quote:</li> </ul> <p>ISO 80000-1_2009</p> <p>In deriving the dimension of a quantity, no account is taken of its scalar, vector, or tensor character.</p> <code>quantity specification, quantity_spec</code> <ul> <li>An entity storing all the information about a specific quantity:<ul> <li>location in a quantity hierarchy</li> <li>quantity equation</li> <li>dimension of a quantity</li> <li>quantity kind</li> <li>quantity character</li> <li>additional constraints (i.e. non-negative)</li> </ul> </li> <li>Dimension of a quantity is not enough to specify all the properties of   a quantity.</li> </ul> <code>unit with an associated quantity, associated unit</code> <ul> <li>Unit that is used to measure quantities of a specific kind in a given   system of units.</li> </ul> <code>quantity reference, reference</code> <ul> <li>According to its definition, quantity can be expressed by means of   a number and a reference</li> <li>In the mp-units library, a reference describes all the required meta-information   associated with a specific quantity (quantity specification and   unit).</li> </ul> <code>absolute quantity point origin</code>, <code>absolute point origin</code> <ul> <li>An explicit point on an axis of values of a specific quantity type that serves   as an absolute reference point for all quantity points which definitions   are (explicitly or implicitly) based on it.</li> <li>For example, mean sea level is commonly used as an absolute reference point to measure altitudes.</li> </ul> <code>quantity point origin</code>, <code>point origin</code> <ul> <li>An explicit point on an axis of values of a specific quantity type serving as a reference   for other quantities.</li> <li>It might be ether an absolute point origin or a compile-time known   quantity point.</li> <li>For example, an ice point is a quantity point with a value of <code>273.15 K</code> that is used as   the zero point of a degree Celsius scale.</li> </ul> <code>quantity point</code>, <code>absolute quantity</code> <ul> <li>An absolute quantity with respect to an origin.</li> <li>For example, timestamp (as opposed to duration), altitude (as opposed to height),   absolute temperature (as opposed to temperature difference).</li> </ul>"},{"location":"appendix/references/","title":"References","text":"<code>ISO80000</code> <p>ISO 80000-1:2009(E) \"Quantities and units \u2014 Part 1: General\", International Organization for Standardization.</p> <code>SIBrochure</code> <p>The International System of Units (SI), International Bureau of Weights and Measures (20 May 2019), ISBN 978-92-822-2272-0.</p> <code>Quincey</code> \"Angles in the SI: a detailed proposal for solving the problem, Quincey, Paul (1 October 2021)."},{"location":"appendix/release_notes/","title":"Release Notes","text":""},{"location":"appendix/release_notes/#mp-units","title":"mp-units","text":""},{"location":"appendix/release_notes/#2.0.0","title":"2.0.0 WIP","text":"<ul> <li><code>units</code> namespace renamed to <code>mp_units</code> (#317)</li> <li>header files in the <code>&lt;mp-units/...&gt;</code> rather then in <code>&lt;units/...&gt;</code> (#317)</li> <li>the downcasting facility is removed (#383, #211, #32)</li> <li>unified and simplified quantity creation (#274)</li> <li>Determining the best way to create a quantity (#413)</li> <li>V2 quantity_point (#414)</li> <li>introduction of <code>quantity_spec</code> to store not only <code>dimension</code> but also additional information about quantities (#405)</li> <li><code>quantity</code> now takes <code>reference</code> object, which aggregates <code>quantity_spec</code> and a <code>unit</code> and a <code>representation</code> type</li> <li>units, prefixes, dimensions, quantity specifications, and references are passed as NTTPs to templates and provide arithmetic operations and comparison</li> <li>expression templates consistently used in all derived types to increase the readability (#351, #166)</li> <li>derived dimensions are now factors of only base dimensions (#281)</li> <li>Interconvertibility of derived quantities (#427)</li> <li>dimensions, quantity specifications, units, and references are now composable, significantly reducing the number of definitions and resulting types</li> <li>heavily simplified unit systems definitions (no need to define unnamed derived units, systems-specific dimensions, aliases for quantities, concepts, UDLs, ... anymore)</li> <li>improved definition of all systems</li> <li>support for all (or at least most) ISO 80000 quantities</li> <li>faster than lightspeed constants (#169)</li> <li>extensions to quantity formatting with <code>fmt</code></li> <li><code>quantity_kind</code> removed</li> <li>much easier and safe casting of unit with <code>operator[]</code> and <code>.number_in(Unit)</code></li> <li>quantity can no longer be constructed with a raw value (#434)</li> <li>Implicit construction of quantities from a value (#410)</li> <li><code>ceil</code> and <code>floor</code> are dangerous (#432)</li> <li>quecto, ronto, ronna, quetta new SI prefixes support</li> <li>many smaller changes not possible to address with the previous design (#205, #210, #134)</li> </ul>"},{"location":"appendix/release_notes/#0.8.0","title":"0.8.0 June 14, 2023","text":"<ul> <li>(!) refactor: <code>common_quantity</code>, <code>common_quantity_for</code>, <code>common_quantity_point</code>, <code>common_quantity_kind</code>, and <code>common_quantity_point_kind</code> removed</li> <li>(!) refactor: <code>named_derived_unit</code> removed as it was not used</li> <li>(!) refactor: <code>derived_unit</code> renamed to <code>derived_scaled_unit</code></li> <li>(!) refactor: <code>unit</code> renamed to <code>derived_unit</code></li> <li>(!) refactor: <code>U::is_named</code> removed from the unit types and replaced with <code>NamedUnit</code> concept</li> <li>(!) refactor: <code>PrefixFamily</code> support removed</li> <li>(!) refactor: <code>mi(naut)</code> renamed to <code>nmi</code></li> <li>(!) refactor: <code>knot</code> unit helper renamed to <code>kn</code> in FPS</li> <li>(!) refactor: <code>knot</code> text symbol changed from <code>\"knot\"</code> to <code>\"kn\"</code></li> <li>refactor: <code>quantity</code> <code>op+()</code> and <code>op-()</code> reimplemented in terms of <code>reference</code> rather then <code>quantity</code> types</li> <li>refactor(example): <code>glide_computer</code> now use dimensionless quantities with <code>ranged_representation</code> as <code>rep</code></li> <li>feat: HEP system support added (thanks @RalphSteinhagen)</li> <li>feat: <code>floor()</code>, <code>ceil()</code>, and <code>round()</code> support added (thanks @hofbi)</li> <li>feat: <code>std::format</code> support for compliant compilers added</li> <li>feat: conversion helpers from <code>mp-units</code> to <code>std::chrono</code> types added</li> <li>feat: math functions can now be safely used with user-defined types</li> <li>feat: conversion from <code>quantity_point</code> to <code>std::chrono::time_point</code> added</li> <li>feat: <code>nautical_mile_per_hour</code> and <code>knot</code> added to <code>si::international</code> system</li> <li>(!) fix: add <code>quantity_point::origin</code>, like <code>std::chrono::time_point::clock</code></li> <li>fix: enable any prefixes for most of the named units (beside those that use prefixes already)</li> <li>fix: <code>hectare</code> definition fixed to be a prefixed version of <code>are</code> + other units</li> <li>fix: account for different dimensions in <code>quantity_point_cast</code>'s constraint</li> <li>fix: output stream operator now properly handles state</li> <li>fix: <code>fmt</code> algorithms were overconstrained with <code>forward_iterator</code></li> <li>fix: CTAD for aliases fixed</li> <li>fix: <code>derived_ratio</code> calculation</li> <li>fix: <code>fill_t</code> assignment operator fixed</li> <li>fix: improve downcast mode off</li> <li>fix: <code>radioactivity</code> header compilation fixed</li> <li>fix: <code>si::hep::dim_momentum</code> duplicated definition fixed</li> <li>fix: <code>fps</code> can now coexist with <code>international</code> system</li> <li>fix: public headers fixed to be standalone</li> <li>test: standalone public headers tests added</li> <li>(!) build: CMake generator in Conan is no longer obtained from an environment variable</li> <li>(!) build: Required Conan version bumped to 1.48</li> <li>(!) build: Conan 1.48 does not set <code>CMAKE_BUILD_TYPE</code> in the <code>conan_toolchain.cmake</code> anymore</li> <li>build: AppleClang 13 support added (thanks @fdischner)</li> <li>build: most of the <code>conanfile.py</code> refactored to be Conan 2.0 ready</li> <li>build: <code>validate()</code> replaced with <code>configure()</code> to raise errors during <code>conan install</code> in Conan 1.X</li> <li>build: minimum Conan version changed to 1.40</li> <li>build: <code>linear-algebra</code> Conan repo is no needed anymore</li> <li>build: Gitpod support added</li> <li>build: clang-format-15 support added</li> <li>build: export config to local build (#322)</li> <li>build: fix export name of <code>mp-units-system</code></li> <li>build: fmt updated to 8.0.1</li> <li>build: gsl-lite updated to 0.40.0</li> <li>build: catch2 updated to 2.13.9</li> <li>build: doxygen updated to 1.9.4</li> <li>build: linear_algebra/0.7.0 switched to wg21-linear_algebra/0.7.2</li> <li>ci: VS2022, gcc-11, clang-13, clang-14, and AppleClang 13 support added</li> <li>ci: pre-commit support added (thanks @hofbi)</li> <li>docs: Project documentation updated</li> <li>docs: <code>CITATION.cff</code> file added</li> <li>docs: <code>CONTRIBUTING.md</code> updated</li> </ul>"},{"location":"appendix/release_notes/#0.7.0","title":"0.7.0 May 11, 2021","text":"<ul> <li>(!) refactor: <code>ScalableNumber</code> renamed to <code>Representation</code></li> <li>(!) refactor: output stream operators moved to the <code>units/quantity_io.h</code> header file</li> <li>(!) refactor: Refactored the library file tree</li> <li>(!) refactor: <code>quantity::count()</code> renamed to <code>quantity::number()</code></li> <li>(!) refactor: <code>data</code> system renamed to <code>isq::iec80000</code> (quantity names renamed too)</li> <li>(!) refactor: <code>*deduced_unit</code> renamed to <code>*derived_unit</code></li> <li>(!) refactor: got rid of a <code>noble_derived_unit</code></li> <li>refactor: quantity (kind) point updated to reflect latest changes to <code>quantity</code></li> <li>refactor: basic concepts, <code>quantity</code> and <code>quantity_cast</code> refactored</li> <li>refactor: <code>abs()</code> definition refactored to be more explicit about the return type</li> <li>feat: quantity (point) kind support added (thanks @johelegp)</li> <li>feat: quantity references support added (thanks @johelegp)</li> <li>feat: quantity aliases support addded</li> <li>feat: interoperability with <code>std::chrono::duration</code> and other units libraries</li> <li>feat: CTAD for dimensionless quantity added</li> <li>feat: <code>modulation_rate</code> support added (thanks @go2sh)</li> <li>feat: SI prefixes for <code>isq::iec80000</code> support added (thanks @go2sh)</li> <li>feat: a possibility to disable quantity UDLs support with <code>UNITS_NO_LITERALS</code> preprocessor define</li> <li>feat: a support to define ISQ derived dimensions in terms of different number or order of components</li> <li>perf: preconditions check do not influence the runtime performance of a Release build</li> <li>perf: <code>quantity_cast()</code> generates less assembly instructions</li> <li>perf: temporary string creation removed from <code>quantity::op&lt;&lt;()</code></li> <li>perf: value initialization for quantity value removed (left with a default initialization)</li> <li>perf: limited the <code>equivalent</code> trait usage</li> <li>perf: limited the C++ Standard Library headers usage</li> <li>perf: rvalue references support added for constructors and getters</li> <li>(!) fix: <code>exp()</code> has sense only for dimensionless quantities</li> <li>(!) fix: <code>dim_torque</code> now properly divides by an angle (instead of multiply) + default unit name change</li> <li>fix: quantity's operators fixed to behave like the underlying types do</li> <li>fix: <code>quantity_cast()</code> fixed to work correctly with representation types not convertible from <code>std::intmax_t</code></li> <li>fix: ambiguous case for empty type list resolved</li> <li>fix: downcasting facility for non-default-constructible types</li> <li>fix: restore user-warnings within the library implementation</li> <li>fix: the text symbol of <code>foot_pound_force</code> and <code>foot_pound_force_per_second</code></li> <li>fix: quantity modulo arithmetics fixed</li> <li>(!) build: Conan testing version is now hosted on Artifactory</li> <li>(!) build: Linear Algebra is now hosted on its Artifactory</li> <li>(!) build: <code>BUILD_DOCS</code> CMake option renamed to <code>UNITS_BUILD_DOCS</code></li> <li>build: doxygen updated to 1.8.20</li> <li>build: catch2 updated to 2.13.4</li> <li>build: fmt updated to 7.1.3</li> <li>build: ms-gsl replaced with gsl-lite/0.38.0</li> <li>build: Conan generator switched to <code>cmake_find_package_multi</code></li> <li>build: Conan CMakeToolchain support added</li> <li>build: CMake scripts cleanup</li> <li>build: ccache support added</li> <li>ci: CI switched from Travis CI to GitHub Actions</li> </ul>"},{"location":"appendix/release_notes/#0.6.0","title":"0.6.0 September 13, 2020","text":"<ul> <li>feat: <code>quantity_point</code> support added (thanks @johelegp)</li> <li>feat: Added angle as SI base dimension (thanks @kwikius)</li> <li>feat: <code>si::angular_velocity</code> support added (thanks @mikeford3)</li> <li>feat: FPS system added (thanks @mikeford3)</li> <li>feat: Added support for mathematical function <code>exp(quantity)</code></li> <li>feat: Localization support for text output added (thanks @rbrugo)</li> <li>feat: Added STL random number distribution wrappers (thanks @yasamoka)</li> <li>(!) refactor: Refactored and cleaned up the library file tree</li> <li>(!) refactor: <code>q_*</code> UDL renamed to <code>_q_*</code></li> <li>(!) refactor: UDLs with \"per\" in name renamed from <code>*p*</code> to <code>*_per_*</code></li> <li>(!) refactor: <code>ratio</code> changed to the NTTP kind</li> <li>(!) refactor: <code>exp</code> and <code>Exp</code> renamed to <code>exponent</code> and <code>Exponent</code></li> <li>(!) refactor: <code>Scalar</code> concept renamed to <code>ScalableNumber</code></li> <li>(!) refactor: Dimensionless quantities redesigned to be of a <code>quantity</code> type</li> <li>refactor: <code>math.h</code> function signatures refactored to use a <code>Quantity</code> concept (thanks @kwikius)</li> <li>refactor: <code>[[nodiscard]]</code> added to many functions</li> <li>fix: <code>si::day</code> unit symbol fixed to <code>d</code> (thanks @komputerwiz)</li> <li>fix: <code>si::mole</code> unit symbol fixed to <code>mol</code> (thanks @mikeford3)</li> <li>(!) build: gcc-9 is no longer supported (at least gcc-10 is required)</li> <li>build: Visual Studio 16.7 support added</li> <li>build: linear_algebra updated to 0.7.0/stable</li> <li>build: fmt updated to 7.0.3</li> <li>build: range-v3 updated to 0.11.0</li> <li>build: catch2 updated to 2.13.0</li> <li>build: doxygen updated to 1.8.18</li> <li>build: ms-gsl 3.1.0 dependency added</li> <li>build: Removed the dependency on a git submodule with common CMake scripts</li> </ul>"},{"location":"appendix/release_notes/#0.5.0","title":"0.5.0 May 17, 2020","text":"<ul> <li>Major refactoring and rewrite of the library</li> <li>Units are now independent from dimensions</li> <li>Dimensions now depend on units (base or coherent units are provided in a class template)</li> <li>Quantity gets a Dimension template parameter again (as unit does not provide information about   its dimension anymore)</li> <li>Spaceship operator support added</li> <li>Added official CGS system support</li> <li>Added official data information system support</li> <li>Repository file tree cleanup</li> <li><code>ratio</code> refactored to contain <code>Exp</code> template parameter (thanks a lot @oschonrock!)</li> <li>SI fundamental constants added</li> <li><code>q_</code> prefix applied to all the UDLs (thanks @kwikius)</li> <li><code>unknown_unit</code> renamed to <code>unknown_coherent_unit</code></li> <li>Project documentation greatly extended and switched to Sphinx</li> <li>A few more usage examples added</li> <li>ASCII-only output support added (thanks @yasamoka)</li> <li>Representation values formatting extended (thanks @rbrugo)</li> <li>Output streams formatting support added</li> <li>Linear algebra from <code>std::experimental::math</code> support added</li> <li>Named SI units and their dimensions added (thanks @rbrugo</li> <li>libfmt updated to 6.2.0</li> <li>Added absolute functions and epsilon to math.h (thanks @mikeford3)</li> <li>Added a lot of prefixes to named units and introduced <code>alias_unit</code> (thanks @yasamoka)</li> <li>Linking with Conan targets only when they exists (#98)</li> <li>All physical dimensions and units put into <code>physical</code> namespace</li> <li>CMake improvements</li> <li>Velocity renamed to speed</li> </ul> <p>Many thanks to GitHub users @oschonrock, @kwikius, and @i-ky for their support in drafting a new library design.</p>"},{"location":"appendix/release_notes/#0.4.0","title":"0.4.0 Nov 17, 2019","text":"<ul> <li>Support for derived dimensions in <code>exp</code> added</li> <li>Added <code>pow()</code> and <code>sqrt()</code> operations on quantities</li> <li><code>units</code> removed from a <code>std::experimental</code> namespace</li> <li>Downcasting facility refactored so the user does not have to write the boilerplate code anymore</li> <li>From now on base dimensions should inherit from <code>base_dimension</code> class template</li> <li>Added unit symbols definitions to <code>base_dimension</code> and derived units</li> <li>Added support for <code>operator&lt;&lt;</code> on <code>quantity</code></li> <li><code>fmt</code> support added</li> <li>Derived unit factory helpers refactored</li> <li>Refactored the way prefixed units are defined</li> </ul>"},{"location":"appendix/release_notes/#0.3.1","title":"0.3.1 Sep 18, 2019","text":"<ul> <li>cmcstl2 dependency changed to range-v3 0.9.1</li> </ul>"},{"location":"appendix/release_notes/#0.3.0","title":"0.3.0 Sep 16, 2019","text":"<ul> <li>The design as described on CppCon 2019 talk (https://youtu.be/0YW6yxkdhlU)</li> <li>Applied the feedback from the Cologne evening session</li> <li><code>upcasting_traits</code> renamed to <code>downcasting_traits</code></li> <li><code>Dimension</code> template parameter removed from quantity</li> <li><code>units</code> moved to a <code>std::experimental</code> namespace</li> <li>Leading underscore prefix removed from UDLs</li> <li>Added a few more derived dimensions</li> <li><code>meter</code> renamed to <code>metre</code></li> <li>Missing <code>operator*</code> added</li> <li>Predefined dimensions moved to a dedicated directory</li> <li><code>dimension_</code> prefix removed from names of derived dimensions</li> <li>cmcstl2 library updated to 2019.09.19</li> <li><code>base_dimension</code> is a value provided as <code>const&amp;</code> to the <code>exp</code> type</li> <li>integrated with Compiler Explorer</li> <li>gsl-lite dependency removed</li> <li>Fractional dimension exponents support added</li> <li><code>QuantityOf</code> concept introduced</li> <li><code>quantity_cast&lt;U, Rep&gt;()</code> support added</li> </ul>"},{"location":"appendix/release_notes/#0.2.0","title":"0.2.0 July 18, 2019","text":"<ul> <li>The design as described on C++Now 2019 talk (https://youtu.be/wKchCktZPHU)</li> <li>Added C++20 features supported by gcc-9.1 (<code>std::remove_cvref_t</code>, down with typename, <code>std::type_identity</code>)</li> <li>Compile-time performance optimizations (<code>type_list</code>, <code>common_ratio</code>, <code>ratio</code>, <code>conditional_t</code>)</li> </ul>"},{"location":"appendix/release_notes/#0.1.0","title":"0.1.0 May 18, 2019","text":"<ul> <li>Initial library release</li> <li>Begin semantic versioning</li> <li>The last version to work with gcc-8</li> </ul>"},{"location":"getting_started/code_example/","title":"Code Example","text":"<p>Here is a small example of operations possible on scalar quantities:</p> <pre><code>#include &lt;mp-units/systems/si/si.h&gt;\nusing namespace mp_units::si::unit_symbols;\n// simple numeric operations\nstatic_assert(10 * km / 2 == 5 * km);\n// unit conversions\nstatic_assert(1 * h == 3600 * s);\nstatic_assert(1 * km + 1 * m == 1001 * m);\n// dimension conversions\ninline constexpr auto kmph = km / h;\nstatic_assert(1 * km / (1 * s) == 1000 * (m / s));\nstatic_assert(2 * kmph * (2 * h) == 4 * km);\nstatic_assert(2 * km / (2 * kmph) == 1 * h);\nstatic_assert(2 * m * (3 * m) == 6 * m2);\nstatic_assert(10 * km / (5 * km) == 2);\nstatic_assert(1000 / (1 * s) == 1 * kHz);\n</code></pre> <p>Try it on Compiler Explorer</p> <p>This library requires some C++20 features (concepts and constraints, classes as NTTP, ...). Thanks to them, the user gets a powerful but still easy-to-use interface where all unit conversions and dimensional analysis can be performed without sacrificing accuracy. Please see the below example for a quick preview of basic library features:</p> <pre><code>#include &lt;mp-units/format.h&gt;\n#include &lt;mp-units/iostream.h&gt;\n#include &lt;mp-units/systems/international/international.h&gt;\n#include &lt;mp-units/systems/isq/space_and_time.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;iostream&gt;\nusing namespace mp_units;\nconstexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d,\nQuantityOf&lt;isq::time&gt; auto t)\n{\nreturn d / t;\n}\nint main()\n{\nusing namespace mp_units::si::unit_symbols;\nusing namespace mp_units::international::unit_symbols;\nconstexpr auto v1 = 110 * (km / h);\nconstexpr auto v2 = 70 * mph;\nconstexpr auto v3 = avg_speed(220. * isq::distance[km], 2 * h);\nconstexpr auto v4 = avg_speed(isq::distance(140. * mi), 2 * h);\nconstexpr auto v5 = v3[m / s];\nconstexpr auto v6 = value_cast&lt;m / s&gt;(v4);\nconstexpr auto v7 = value_cast&lt;int&gt;(v6);\nstd::cout &lt;&lt; v1 &lt;&lt; '\\n';                                  // 110 km/h\nstd::cout &lt;&lt; v2 &lt;&lt; '\\n';                                  // 70 mi/h\nstd::cout &lt;&lt; std::format(\"{}\", v3) &lt;&lt; '\\n';               // 110 km/h\nstd::cout &lt;&lt; std::format(\"{:*^14}\", v4) &lt;&lt; '\\n';          // ***70 mi/h****\nstd::cout &lt;&lt; std::format(\"{:%Q in %q}\", v5) &lt;&lt; '\\n';      // 30.5556 in m/s\nstd::cout &lt;&lt; std::format(\"{0:%Q} in {0:%q}\", v6) &lt;&lt; '\\n'; // 31.2928 in m/s\nstd::cout &lt;&lt; std::format(\"{:%Q}\", v7) &lt;&lt; '\\n';            // 31\n}\n</code></pre> <p>Try it on Compiler Explorer</p> <p>Note</p> <p>You can find more code examples in the Examples chapter.</p>"},{"location":"getting_started/faq/","title":"Frequently Asked Questions","text":""},{"location":"getting_started/faq/#why-do-we-spell-metre-instead-of-meter","title":"Why do we spell <code>metre</code> instead of <code>meter</code>?","text":"<p>This is how the BIPM defines it in the SI Brochure (British English spelling by default).</p>"},{"location":"getting_started/faq/#why-dont-we-use-udls-to-create-quantities","title":"Why don't we use UDLs to create quantities?","text":"<p>Many reasons make UDLs a poor choice for a physical units library:</p> <ol> <li>UDLs work only with literals (compile-time known values). Our observation is that besides    the unit tests, there are few compile-time known constants used in the production code.</li> <li> <p>Typical implementations of UDLs tend to always use the widest representation type available.    In the case of <code>std::chrono::duration</code>, the following is true:</p> <pre><code>using namespace std::chrono_literals;\nauto d1 = 42s;\nauto d2 = 42.s;\nstatic_assert(std::is_same_v&lt;decltype(d1)::rep, std::int64_t&gt;);\nstatic_assert(std::is_same_v&lt;decltype(d2)::rep, long double&gt;);\n</code></pre> </li> <li> <p>While increasing the coverage for the library, we learned that many unit symbols conflict  with    built-in types or numeric extensions. A few of those are: <code>F</code> (farad), <code>J</code> (joule), <code>W</code> (watt),    <code>K</code> (kelvin), <code>d</code> (day), <code>l</code> or <code>L</code> (litre), <code>erg</code>, <code>ergps</code>. For a while for those we used <code>_</code> prefix    to make the library work at all, but at some point, we had to unify the naming, and we came up with <code>_q_</code>    prefix, which resulted in creating a quantity of a provided unit. So in case the library is    standardized, all quantities would be created with UDLs having <code>q_</code> prefix (i.e. <code>42q_s</code>)    which is not that nice anymore.</p> </li> <li> <p>UDLs with the same identifiers defined in different namespace can't be disambiguated in the C++    language. If both SI and CGS systems define <code>_q_s</code> UDL for a second unit, then it would not be possible    to specify which one to use in case both namespaces are \"imported\".</p> </li> <li> <p>Another bad property of UDLs is that they do not compose. A coherent unit of angular momentum would    have a UDL specified as <code>_q_kg_m2_per_s</code>. Now imagine that you want to make every possible user happy.    How many variations of that unit would you predefine for differently scaled versions of unit ingredients?</p> </li> <li> <p>UDLs are also really expensive to define and specify. For each unit, we need two definitions. One for    integral and another one for floating-point representation. Before the V2 framework, the coherent unit of    angular momentum was defined as:</p> <pre><code>constexpr auto operator\"\" _q_kg_m2_per_s(unsigned long long l)\n{\ngsl_ExpectsAudit(std::in_range&lt;std::int64_t&gt;(l));\nreturn angular_momentum&lt;kilogram_metre_sq_per_second, std::int64_t&gt;(static_cast&lt;std::int64_t&gt;(l));\n}\nconstexpr auto operator\"\" _q_kg_m2_per_s(long double l)\n{\nreturn angular_momentum&lt;kilogram_metre_sq_per_second, long double&gt;(l);\n}\n</code></pre> </li> </ol>"},{"location":"getting_started/faq/#why-cant-i-create-a-quantity-by-passing-a-number-to-a-constructor","title":"Why can't I create a quantity by passing a number to a constructor?","text":"<p>A quantity class template in the mp-units library has no publicly available constructor taking a raw value. Such support is provided by the <code>std::chrono::duration</code> and was pointed out to us as a red flag safety issue by a few parties already.</p> <p>Consider the following structure and a code using it:</p> <pre><code>struct X {\nstd::vector&lt;std::chrono::milliseconds&gt; vec;\n// ...\n};\n</code></pre> <pre><code>X x;\nx.vec.emplace_back(42);\n</code></pre> <p>Everything works fine for years until at some point someone changes the structure to:</p> <pre><code>struct X {\nstd::vector&lt;std::chrono::microseconds&gt; vec;\n// ...\n};\n</code></pre> <p>The code continues to compile just fine but all the calculations are off now. This is why we decided to not follow this path.</p> <p>In the mp-units library, both a number and a unit have to always be explicitly provided in order to form a quantity.</p>"},{"location":"getting_started/faq/#why-60-km-h-does-not-compile","title":"Why <code>60 * km / h</code> does not compile?","text":"<p>The library design does not allow multiplying or dividing a quantity (the result of <code>60 * km</code>) by another unit. This significantly limits the number of possible errors and surprises in the quantity equations.</p> <p>Consider the following expression:</p> <pre><code>auto q = 60 * km / 2 * h;\n</code></pre> <p>Looks like <code>30 km/h</code>, right? But it is not. If the above code was allowed, it would result in <code>30 km\u22c5h</code>. In case you want to divide <code>60 * km</code> by <code>2 * h</code> a parenthesis is needed <code>60 * km / (2 * h)</code>.</p> <p>Another surprising issue could result from the following code:</p> <pre><code>template&lt;typename T&gt;\nauto make_length(T v) { return v * si::metre; }\nauto v = 42;\nauto q = make_length(v);\n</code></pre> <p>The above might look like a good idea, but consider what would happen in the user provided an already existing quantity:</p> <pre><code>auto v = 42 * m;\nauto q = make_length(v);\n</code></pre> <p>Fortunately, with the current design, such issues are detected at compile-time.</p>"},{"location":"getting_started/faq/#why-a-dimensionless-quantity-is-not-just-a-fundamental-arithmetic-type","title":"Why a dimensionless quantity is not just a fundamental arithmetic type?","text":"<p>In the initial design of this library, the resulting type of division of two quantities was their common representation type:</p> <pre><code>static_assert(std::is_same_v&lt;decltype(10 * km / (5 * km)), std::int64_t&gt;);\n</code></pre> <p>First of all, this was consistent with <code>std::chrono::duration</code> behavior. Additional reasoning behind it was not providing a false impression of a strong <code>quantity</code> type for something that looks and feels like a regular number. Also, all of the mathematic and trigonometric functions were working fine out of the box with such representation types, so we did not have to rewrite <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, and others.</p> <p>However, the feedback we got from the production usage was that such an approach is really bad for generic programming. It is hard to handle the result of the two quantities' division (or multiplication) as it might be either a quantity or a fundamental type. If we want to raise such a result to some power, we must use <code>units::pow</code> or <code>std::pow</code> depending on the resulting type. Those are only a few issues related to such an approach.</p> <p>Moreover, suppose you divide quantities of the same dimension but with units of significantly different magnitudes. In that case, you may end up with a really small or a huge floating-point value, which may result in losing lots of precision. Returning a dimensionless quantity from such cases allows us to benefit from all the properties of scaled units and is consistent with the rest of the library.</p> <p>Info</p> <p>More information on the current design can be found in the Dimensionless Quantities chapter.</p>"},{"location":"getting_started/faq/#why-unicode-quantity-symbols-are-used-by-default-instead-of-ascii-only-characters","title":"Why Unicode quantity symbols are used by default instead of ASCII-only characters?","text":"<p>Both C++ and ISO 80000 are standardized by the ISO. ISO 80000 and the SI standards specify Unicode symbols as the official unit names for some quantities (i.e. <code>\u03a9</code> symbol for the resistance quantity). As mp-units library will be proposed for standardization as a part of the C++ Standard Library we have to obey the rules and be consistent with ISO specifications.</p> <p>Info</p> <p>We do understand engineering reality and the constraints of some environments. This is why the library has the option of ASCII-only Quantity Symbols.</p>"},{"location":"getting_started/faq/#why-dont-you-have-cmake-options-to-disable-the-building-of-tests-and-examples","title":"Why don't you have CMake options to disable the building of tests and examples?","text":"<p>Over time many people provided PRs proposing adding options to build tests and examples conditionally. Here are a few examples:</p> <ul> <li>Add CMake options for disabling docs, examples and tests</li> <li>build: add options to disable part of the build</li> <li>CMake Refactoring and Option Cleanup</li> </ul> <p>We admit this is a common practice in the industry, but we also believe this is a bad pattern.</p> <p>First, the only need for such options comes when a user wants to use <code>add_subdirectory()</code> in CMake to handle dependencies. Such an approach does not scale and should be discouraged. There is little use for such a practice in times when we have dedicated package managers like Conan.</p> <p>The second thing is that our observation is that many people are fixed on disabling \"unneeded\" subdirectories from compilation, but they do not see or address the biggest issue, which is polluting user's build environment with our development-specific settings. Propagating our restrictive compilation flags to user's project is not the best idea as it might cause a lot of harm if this project stops to compile because of that.</p> <p>Last but not least, not having those options is on purpose. Top level CMakeLists.txt file should only be used by mp-units developers and contributors as an entry point for project's development. We want to ensure that everyone will build ALL the code correctly before pushing a commit. Having such options would allow unintended issues to leak to PRs and CI.</p> <p>This is why our projects have two entry points:</p> <ul> <li>./CMakeLists.txt is to be used by projects developers to build ALL the project code with really   restrictive compilation flags,</li> <li>./src/CMakeLists.txt contains only a pure library definition and should be used by the customers   that prefer to use CMake's <code>add_subdirectory()</code> to handle the dependencies.</li> </ul> <p>Info</p> <p>For more details on this please refer to the CMake + Conan: 3 Years Later - Mateusz Pusz lecture that Mateusz Pusz provided at the C++Now 2021 conference.</p>"},{"location":"getting_started/installation_and_usage/","title":"Installation And Usage","text":"<p>Info</p> <p>mp-units library tries to provide the best user experience possible with the C++ language. To achieve that, it extensively uses C++20 features and the explicit object parameter from C++23.</p> <p>Even though the library benefits from C++23 (if available), C++20 is enough to compile and use all of the library's functionality. C++23 features are hidden behind a preprocessor macro providing a backward-compatible way to use it.</p> <p>Sadly, as of today, not many compilers provide full C++20 support. The library compiles fine on the following compilers (or newer):</p> <ul> <li>gcc-12.2</li> </ul> <p>In the upcoming weeks, we will be actively working to extend the support to other compilers as well.</p>"},{"location":"getting_started/installation_and_usage/#repository-structure-and-dependencies","title":"Repository Structure and Dependencies","text":"<p>This repository contains three independent CMake-based projects:</p> <ul> <li> <p>./src</p> <ul> <li>header-only project containing whole mp-units library</li> <li>./src/CMakeList.txt file is intended as an entry point for library users</li> <li> <p>in case this library becomes part of the C++ standard, it will have no external dependencies   but until then, it depends on the following:</p> <ul> <li>gsl-lite to verify runtime contracts with   the <code>gsl_Expects</code> macro,</li> <li>{fmt} to provide text formatting of quantities   (if <code>std::format</code> is not supported yet on a specific compiler),</li> <li>[only for clang &lt; 14 with libc++] range-v3   to provide needed C++20 concepts and utilities.</li> </ul> </li> </ul> </li> <li> <p>.</p> <ul> <li>project used as an entry point for library development and CI/CD</li> <li>it wraps ./src project together with usage examples and tests</li> <li> <p>additionally to the dependencies of ./src project, it uses:</p> <ul> <li><code>Catch2 &lt;https://github.com/catchorg/Catch2&gt;</code>_ library as a unit tests framework,</li> <li><code>linear algebra &lt;https://github.com/BobSteagall/wg21/tree/master/include&gt;</code>   library based on proposal <code>P1385 &lt;https://wg21.link/P1385&gt;</code> used in some examples   and tests.</li> </ul> </li> <li> <p>in case you also want to generate the project's documentation, you will need:</p> <ul> <li>Material for MkDocs</li> </ul> </li> </ul> </li> <li> <p>./test_package</p> <ul> <li>library installation and Conan package verification.</li> </ul> </li> </ul> <p>Tip</p> <p>Top level CMakeLists.txt file should only be used by mp-units developers and contributors as an entry point for the project's development. We want to ensure that everyone will build ALL the code correctly before pushing a commit. Having such options would allow unintended issues to leak to PRs and CI.</p> <p>This is why our projects have two entry points:</p> <ul> <li>./CMakeLists.txt is to be used by projects developers to build ALL the project code with really restrictive compilation flags,</li> <li>./src/CMakeLists.txt contains only a pure library definition and should be used by the customers that prefer to use CMake's <code>add_subdirectory()</code> to handle the dependencies.</li> </ul> <p>To learn more about the rationale, please check our FAQ.</p>"},{"location":"getting_started/installation_and_usage/#obtaining-dependencies","title":"Obtaining Dependencies","text":"<p>This library assumes that most of the dependencies will be provided by the Conan Package Manager. If you want to obtain required dependencies by other means, some modifications to the library's CMake files might be needed. The rest of the dependencies responsible for documentation generation are provided by <code>python3-pip</code>.</p>"},{"location":"getting_started/installation_and_usage/#conan-quick-intro","title":"Conan Quick Intro","text":"<p>In case you are not familiar with Conan, to install it (or upgrade) just do:</p> <pre><code>pip3 install -U conan\n</code></pre> <p>After that, you might need to add a custom profile file for your development environment in ~/.conan2/profiles directory. An example profile can look as follows:</p> ~/.conan2/profiles/gcc12<pre><code>[settings]\narch=x86_64\nbuild_type=Release\ncompiler=gcc\ncompiler.cppstd=20\ncompiler.libcxx=libstdc++11\ncompiler.version=12\nos=Linux\n[conf]\ntools.build:compiler_executables={\"c\": \"gcc-12\", \"cpp\": \"g++-12\"}\n</code></pre> <p>Tip</p> <p>Please note that the mp-units library requires C++20 to be set in a Conan profile or forced via the Conan command line. If you do the former, you will not need to provide <code>-s compiler.cppstd=20</code> every time your run a Conan command line (as provided in the command line instructions below).</p> <p>Additionally, it is recommended to set Ninja as a CMake generator for Conan. To do so, you should create a ~/.conan2/global.conf file that will set <code>tools.cmake.cmaketoolchain:generator</code> to one of Ninja generators. For example:</p> ~/.conan2/global.conf<pre><code>tools.cmake.cmaketoolchain:generator=\"Ninja Multi-Config\"\n</code></pre> <p>Note</p> <p>~/.conan2/global.conf file may also set <code>tools.cmake.cmake_layout:build_folder_vars</code> which makes working with several compilers or build configurations easier. For example, the below line will force Conan to generate separate CMake presets and folders for each compiler:</p> ~/.conan2/global.conf<pre><code>tools.cmake.cmake_layout:build_folder_vars=[\"settings.compiler\", \"settings.compiler.version\"]\n</code></pre> <p>In such a case, you will need to use a configuration-specific preset name in the Conan instructions provided below rather then just <code>conan-default</code> and <code>conan-release</code> (i.e. <code>conan-gcc-11</code> and <code>conan-gcc-11-release</code>)</p>"},{"location":"getting_started/installation_and_usage/#build-options","title":"Build Options","text":""},{"location":"getting_started/installation_and_usage/#conan-configuration-properties","title":"Conan Configuration Properties","text":"<code>user.build:all</code> <p> 0.8.0 \u00b7  <code>True</code>/<code>False</code> (Default: <code>False</code>)</p> <p>Enables compilation of all the source code including tests and examples. To support this it requires some additional Conan build dependencies described in Repository Structure and Dependencies. It also runs unit tests during Conan build (unless <code>tools.build:skip_test</code> configuration property is set to <code>True</code>).</p> <code>user.build:skip_la</code> <p> 0.8.0 \u00b7  <code>True</code>/<code>False</code> (Default: <code>False</code>)</p> <p>If <code>user.build:all</code> is enabled, among others, Conan installs the external wg21-linear_algebra dependency and enables the compilation of linear algebra-based tests and usage examples. Such behavior can be disabled with this option.</p>"},{"location":"getting_started/installation_and_usage/#cmake-options","title":"CMake Options","text":"<code>MP_UNITS_AS_SYSTEM_HEADERS</code> <p> 2.0.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Exports library as system headers.</p> <code>MP_UNITS_BUILD_LA</code> <p> 2.0.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>ON</code>)</p> <p>Enables building code depending on the linear algebra library.</p> <code>MP_UNITS_IWYU</code> <p> 2.0.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Enables <code>include-what-you-use</code> when compiling with a clang compiler. Additionally turns on <code>MP_UNITS_AS_SYSTEM_HEADERS</code>.</p> <code>MP_UNITS_USE_LIBFMT</code> <p> 2.0.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>ON</code>)</p> <p>Enables usage of {fmt} library instead of the C++20 Standard Library feature.</p>"},{"location":"getting_started/installation_and_usage/#cmake-with-presets-support","title":"CMake with Presets Support","text":"<p>It is recommended to use at least CMake 3.23 to build this project as this version introduced support for CMake Presets schema version 4 used now by Conan to generate presets files. All build instructions below assume that you have such support. If not, your CMake invocations have to be replaced with something like:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. -G \"Ninja Multi-Config\" -DCMAKE_TOOLCHAIN_FILE=&lt;path_to_generators_dir&gt;/conan_toolchain.cmake\ncmake --build . --config Release\n</code></pre> <p>Note</p> <p>In case you can't use CMake 3.23 but you have access to CMake 3.20 or later, you can append <code>-c tools.cmake.cmaketoolchain.presets:max_schema_version=2</code> to the <code>conan install</code> command which will force Conan to use an older version of the CMake Presets schema.</p>"},{"location":"getting_started/installation_and_usage/#installation-and-reuse","title":"Installation and Reuse","text":"<p>There are many different ways of installing/reusing mp-units in your project. Below we mention only a few of many options possible.</p> <p>Info</p> <p>The easiest and most recommended way to obtain mp-units is with the Conan package manager. See Conan + CMake (release) for a detailed instruction.</p>"},{"location":"getting_started/installation_and_usage/#copy","title":"Copy","text":"<p>As mp-units is a C++ header-only library you can simply copy all needed src/*/include subdirectories to your source tree.</p> <p>Note</p> <p>In such a case, you are on your own to ensure all the dependencies are installed, and their header files can be located during the build. Please also note that some compiler-specific flags are needed to make the code compile without issues.</p>"},{"location":"getting_started/installation_and_usage/#copy-cmake","title":"Copy + CMake","text":"<p>If you copy the whole mp-units repository to your project's file tree, you can reuse CMake targets defined by the library. To do so, you should use CMakeLists.txt file from the ./src directory:</p> <pre><code>add_subdirectory(&lt;path_to_units_folder&gt;/src)\n# ...\ntarget_link_libraries(&lt;your_target&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; mp-units::mp-units)\n</code></pre> <p>Note</p> <p>You are still on your own to make sure all the dependencies are installed and their header and CMake configuration files can be located during the build.</p>"},{"location":"getting_started/installation_and_usage/#conan-cmake-release","title":"Conan + CMake (release)","text":"<p>Tip</p> <p>If you are new to the Conan package manager, it is highly recommended to read Obtaining Dependencies and refer to Consuming packages chapter of the official Conan documentation for more information.</p> <p>mp-units releases are hosted on Conan-Center. To obtain an official library release, the following steps may be performed:</p> <ol> <li> <p>Create Conan configuration file (either conanfile.txt or conanfile.py) in your    project's top-level directory and add mp-units as a dependency of your project.    For example, the simplest file may look as follows:</p> conanfile.txt<pre><code>[requires]\nmp-units/0.8.0\n[layout]\ncmake_layout\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> </li> <li> <p>Import mp-units and its dependencies definitions to your project's build procedure    with <code>find_package</code>:</p> <pre><code>find_package(mp-units CONFIG REQUIRED)\n</code></pre> </li> <li> <p>Link your CMake targets with mp-units:</p> <pre><code>target_link_libraries(&lt;your_target&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; mp-units::mp-units)\n</code></pre> </li> <li> <p>Download, build, and install Conan dependencies before running the CMake configuration step:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing\ncmake --preset conan-default\ncmake --build --preset conan-release\n</code></pre> </li> </ol>"},{"location":"getting_started/installation_and_usage/#conan-cmake-live-at-head","title":"Conan + CMake (Live At Head)","text":"<p>This chapter describes the procedure to Live At Head, which means using the latest version of mp-units all the time.</p> <p>Note</p> <p>Please note that even though the Conan packages that you will be using are generated ONLY for builds that are considered stable (passed our CI tests) some minor regressions may happen (our CI and C++20 build environment is not perfect yet). Also, please expect that the library interface might, and probably will, change occasionally. Even though we do our best, such changes might not be reflected in the project's documentation right away.</p> <p>The procedure is similar to the one described in Conan + CMake (release) with the following differences:</p> <ol> <li> <p>Before starting the previous procedure, add mp-units remote to your Conan configuration:</p> <pre><code>conan remote add conan-mpusz https://mpusz.jfrog.io/artifactory/api/conan/conan-oss\n</code></pre> </li> <li> <p>In your Conan configuration file, provide the package identifier of the <code>mpusz/testing</code> stream:</p> conanfile.txt<pre><code>[requires]\nmp-units/2.0.0@mpusz/testing\n[layout]\ncmake_layout\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> <p>Tip</p> <p>The identifiers of the latest packages can always be found in the project's README file or on the project's Artifactory.</p> </li> <li> <p>Force Conan to check for updated recipes with <code>-u</code>:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing -u\n</code></pre> </li> </ol>"},{"location":"getting_started/installation_and_usage/#install","title":"Install","text":"<p>In case you don't want to use Conan in your project and just want to install the mp-units library on your file system and use <code>find_package(mp-units)</code> from another repository to find it, it is enough to perform the following steps:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing\nmv CMakeUserPresets.json src\ncd src\ncmake --preset conan-default -DCMAKE_INSTALL_PREFIX=&lt;your_installation_path&gt;\ncmake --build --preset conan-release --target install\n</code></pre>"},{"location":"getting_started/installation_and_usage/#contributing-or-just-building-all-the-tests-and-examples","title":"Contributing (or just building all the tests and examples)","text":"<p>In case you would like to build all the mp-units source code (with unit tests and examples), you should:</p> <ol> <li>Use the CMakeLists.txt from the top-level directory.</li> <li>Run Conan with <code>user.build:all</code> = <code>True</code>.</li> </ol> <pre><code>git clone https://github.com/mpusz/mp-units.git &amp;&amp; cd units\nconan build . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -c user.build:all=True -b missing\n</code></pre> <p>The above will download and install all of the dependencies needed for the development of the library, build all of the source code, and run unit tests.</p> <p>If you prefer to build the project via CMake rather than Conan, then you should replace the <code>conan build</code> with <code>conan install</code> command and then follow with a regular CMake build:</p> <pre><code>cmake --preset conan-default\ncmake --build --preset conan-release\ncmake --build --preset conan-release --target test\n</code></pre>"},{"location":"getting_started/installation_and_usage/#building-documentation","title":"Building documentation","text":"<p>Starting from mp-units 2.0 we are using Material for MkDocs to build our documentation. The easiest way to install all the required dependencies is with <code>pip</code>:</p> <pre><code>pip install -U mkdocs-material\n</code></pre> <p>After that, you can either:</p> <ul> <li> <p>easily start a live server to preview the documentation as you write</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>build the documentation</p> <pre><code>mkdocs build\n</code></pre> </li> </ul>"},{"location":"getting_started/installation_and_usage/#packaging","title":"Packaging","text":"<p>To test CMake installation and Conan packaging or create a Conan package run:</p> <pre><code>conan create . &lt;username&gt;/&lt;channel&gt; -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -c user.build:all=True -b missing\n</code></pre> <p>The above will create a Conan package and run tests provided in ./test_package directory.</p>"},{"location":"getting_started/installation_and_usage/#uploading-mp-units-package-to-the-conan-server","title":"Uploading mp-units Package to the Conan Server","text":"<pre><code>conan upload -r &lt;remote-name&gt; --all mp-units/2.0.0@&lt;user&gt;/&lt;channel&gt;\n</code></pre>"},{"location":"getting_started/introduction/","title":"Introduction","text":"<p>mp-units is a Modern C++ library that provides compile-time dimensional analysis and unit/quantity manipulation. The initial versions of the library were inspired by the <code>std::chrono::duration</code> but with each release, the interfaces diverged from the original to provide a better user experience.</p>"},{"location":"getting_started/introduction/#open-source","title":"Open Source","text":"<p>mp-units is Free and Open Source, with a permissive MIT license. Check out the source code and issue tracking (for questions and support, reporting bugs, suggesting feature requests and improvements) at https://github.com/mpusz/mp-units.</p>"},{"location":"getting_started/introduction/#with-the-users-experience-in-mind","title":"With the User's Experience in Mind","text":"<p>Most of the critical design decisions in the library are dictated by the requirement of providing the best user experience possible. Other C++ physical units libraries are \"famous\" for their enormous and hard-to-understand error messages (one line of the error log often do not fit on one slide). The ultimate goal of mp-units is to improve this and make compile-time errors and debugging as easy and user-friendly as possible.</p> <p>To achieve this goal, several techniques are applied:</p> <ul> <li>usage of C++20 concepts,</li> <li>using strong types for framework entities (instead of type aliases),</li> <li>usage of expression templates to improve the readability of generated types,</li> <li>limiting the number of template arguments to the bare minimum.</li> </ul> <p>Note</p> <p>In many generic C++ libraries compile-time errors do not happen often. It is hard to break <code>std::string</code> or <code>std::vector</code> in a way it won't compile with a huge error log. Physical Units libraries are different. Generation of compile-time errors is the main reason to use such a library.</p>"},{"location":"getting_started/introduction/#key-features","title":"Key Features","text":"Feature Description Safety - The affine space strong types (<code>quantity</code> and <code>quantity_point</code>)- Compile-time checked conversions of quantities and units- Unique support for many quantities of the same kind- Type-safe equations on scalar, vector, and tensor quantities and their units- Value-preserving conversions Performance - All the compile-time logic implemented as immediate (<code>consteval</code>) functions- As fast or even faster than working with fundamental types- No space size overhead needed to implement high-level abstractions Great User Experience - Optimized for readable compilation errors and great debugging experience- Efficient and composable way to specify a unit of choice- Value-based dimension, unit, and quantity equations Feature Rich - Systems of Quantities- Systems of Units- Scalar, vector, and tensor quantities- The affine space- Natural units systems support- Strong angular system- Supports any unit's magnitude (huge, small, floating-point)- Faster-than-lightspeed constants- Highly adjustable text-output formatting Easy to Extend - Each entity can be defined with a single line of code- User can easily extend the systems with custom dimensions, quantities, and units Low Standardization Cost - Small number of predefined entities needed thanks to composability- No external dependencies (assuming full C++20 support)- No macros in the user interface (besides portability and standard-compliance issues)- Possibility to be standardized as a freestanding part of the C++ Standard Library"},{"location":"getting_started/quick_start/","title":"Quick Start","text":"<p>A quantity is a concrete amount of a unit for a quantity type of a specified dimension with a specific representation, and is represented in the library with a <code>quantity</code> class template.</p>"},{"location":"getting_started/quick_start/#creating-a-quantity","title":"Creating a quantity","text":"<p>The quantity is created by multiplying a number with a predefined unit:</p> <pre><code>#include &lt;mp-units/systems/si/si.h&gt;\nusing namespace mp_units;\nauto q = 42 * si::metre;\n</code></pre> <p>Note</p> <p>The above spelling of <code>metre</code> is not a typo. For motivation, please check our FAQ.</p> <p>The above creates an instance of <code>quantity&lt;si::metre(), int&gt;</code>. The same can be obtained using an optional unit symbol:</p> <pre><code>#include &lt;mp-units/systems/si/si.h&gt;\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\nauto q = 42 * m;\n</code></pre> <p>Note</p> <p>Unit symbols introduce a lot of short identifiers into the current namespace, and that is why they are opt-in. A user has to explicitly \"import\" them from a dedicated <code>unit_symbols</code> namespace.</p>"},{"location":"getting_started/quick_start/#user-provided-unit-wrappers","title":"User-provided unit wrappers","text":"<p>Sometimes it might be awkward to type some derived units:</p> <pre><code>auto speed = 60 * (km / h);\n</code></pre> <p>Note</p> <p>Please note that <code>60 * km / h</code> will not compile. To read more about the rationale for such a design please check our FAQ.</p> <p>In case such a unit is used a lot in the project, a user can easily provide a nicely named wrapper for it with:</p> <pre><code>constexpr auto kmph = km / h;\nauto speed = 60 * kmph;\n</code></pre> <p>or even:</p> <pre><code>constexpr auto kilometre = si::kilo&lt;si::metre&gt;;\nconstexpr auto kilometre_per_hour = kilometre / si::hour;\nconstexpr auto kmph = kilometre_per_hour;\nauto speed = 60 * kmph;\n</code></pre> <p>Note</p> <p>In case you wonder why this library does not use UDLs to create quantities, please check our FAQ.</p>"},{"location":"library_reference/core_library/","title":"Core Library","text":""},{"location":"library_reference/core_library/#concepts","title":"Concepts","text":""},{"location":"library_reference/core_library/#expression-templates","title":"Expression templates","text":""},{"location":"library_reference/core_library/#dimensions","title":"Dimensions","text":""},{"location":"users_guide/terms_and_definitions/","title":"Terms and Definitions","text":"<p>The mp-units project consistently uses the official metrology vocabulary defined by the ISO and BIPM. You can find essential project-related definitions in our documentation's \"Glossary\" chapter. Even more, terms are provided in the official vocabulary of the ISO and BIPM.</p> <p>Tip</p> <p>Please familiarize yourself with terms from \"Glossary\" to better understand the documentation and improve domain-related communication and discussions.</p>"},{"location":"users_guide/examples/hello_units/","title":"<code>hello_units</code>","text":"<p>This is a really simple example showcasing the features of the mp-units library.</p> hello_units.cpp<pre><code>#include &lt;mp-units/format.h&gt;\n#include &lt;mp-units/iostream.h&gt;\n#include &lt;mp-units/systems/international/international.h&gt;\n#include &lt;mp-units/systems/isq/space_and_time.h&gt;\n#include &lt;mp-units/systems/si/unit_symbols.h&gt;\n#include &lt;iostream&gt;\n</code></pre> <p>First, we include the headers for:</p> <ul> <li>a system of quantities (ISQ)</li> <li>symbols of SI units</li> <li>symbols of international units</li> <li>text and stream output support</li> </ul> hello_units.cpp<pre><code>using namespace mp_units;\n</code></pre> <p>Next, to shorten the definitions, we \"import\" <code>mp_units</code> namespace.</p> hello_units.cpp<pre><code>constexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d, QuantityOf&lt;isq::time&gt; auto t)\n{\nreturn d / t;\n}\n</code></pre> <p>The above function template takes any quantities implicitly convertible to <code>isq::length</code> and <code>isq::time</code>. Those quantities can use any compatible unit and a representation type. The function returns a result of a really simple equation and ensures that its quantity type is implicitly convertible to <code>isq::speed</code>.</p> <p>Note</p> <p>Besides verifying the type returned from the function, constraining a generic return type is really useful for users of such a function as it provides more information of what to expect from a function than just using <code>auto</code>.</p> hello_units.cpp<pre><code>int main()\n{\nusing namespace mp_units::si::unit_symbols;\nusing namespace mp_units::international::unit_symbols;\n</code></pre> <p>The above lines explicitly opt-in to use unit symbols from two systems of units. As this introduces a lot of short identifiers into the current scope, it is not done implicitly while including a header file.</p> hello_units.cpp<pre><code>  constexpr auto v1 = 110 * (km / h);\nconstexpr auto v2 = 70 * mph;\nconstexpr auto v3 = avg_speed(220. * km, 2 * h);\nconstexpr auto v4 = avg_speed(isq::distance(140. * mi), 2 * isq::duration[h]);\nconstexpr auto v5 = v3[m / s];\nconstexpr auto v6 = value_cast&lt;m / s&gt;(v4);\nconstexpr auto v7 = value_cast&lt;int&gt;(v6);\n</code></pre> <ul> <li>Lines <code>16</code> &amp; <code>17</code> create a quantity of kind <code>isq::length / isq::time</code> with the numbers   and units provided. Such quantities can be converted or assigned to any other quantity   with a matching kind.</li> <li>Line <code>18</code> calls our function template with quantities of kind <code>isq::length</code> and   <code>isq::time</code> and number and units provided.</li> <li>Line <code>19</code> explicitly specifies quantity specifications of the quantities passed   to a function template. This time those will not be quantity kinds anymore and will   have more restrictive conversion rules.</li> <li>Line <code>20</code> changes the unit of a quantity <code>v3</code> to <code>m / s</code> in a value-preserving way   (floating-point representations are considered to be value-preserving).</li> <li>Line <code>21</code> does a similar operation but this time it would succeed also for non-truncating   cases (if it was the case).</li> <li>Line <code>22</code> does a value-truncating operation of changing the underlying representation   type from <code>double</code> to <code>int</code>.</li> </ul> hello_units.cpp<pre><code>  std::cout &lt;&lt; v1 &lt;&lt; '\\n';                                                // 110 km/h\nstd::cout &lt;&lt; v2 &lt;&lt; '\\n';                                                // 70 mi/h\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{}\", v3) &lt;&lt; '\\n';                // 110 km/h\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:*^14}\", v4) &lt;&lt; '\\n';           // ***70 mi/h****\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:%Q in %q}\", v5) &lt;&lt; '\\n';       // 30.5556 in m/s\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{0:%Q} in {0:%q}\", v6) &lt;&lt; '\\n';  // 31.2928 in m/s\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:%Q}\", v7) &lt;&lt; '\\n';             // 31\n}\n</code></pre> <p>The above presents various ways to print a quantity. Both stream insertion operations and <code>std::format</code> are supported.</p> <p>Note</p> <p><code>MP_UNITS_STD_FMT</code> is used for compatibility reasons. In case a specific compiler does not support <code>std::format</code> or a user prefers to use <code>{fmt}</code> library, this macro will resolve to <code>fmt</code> namespace. Otherwise, <code>std</code> namespace will be used.</p>"},{"location":"users_guide/framework_basics/basic_concepts/","title":"Basic Concepts","text":"<p>The most important concepts in the mp-units library are <code>Dimension</code>, <code>QuantitySpec</code>, <code>Unit</code>, <code>Reference</code>, <code>Representation</code>, <code>Quantity</code>, and <code>QuantityPoint</code>:</p> <pre><code>flowchart TD\n    Dimension --- QuantitySpec\n    QuantitySpec --- Reference\n    Unit --- Reference\n    Reference --- Quantity\n    Representation --- Quantity\n    Quantity --- QuantityPoint\n    PointOrigin --- QuantityPoint\n\n    click Dimension \"#dimension\"\n    click QuantitySpec \"#quantityspec\"\n    click Unit \"#unit\"\n    click Reference \"#reference\"\n    click Representation \"#representation\"\n    click Quantity \"#quantity\"\n    click PointOrigin \"#pointorigin\"\n    click QuantityPoint \"#quantitypoint\"</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#dimension","title":"<code>Dimension</code>","text":"<p><code>Dimension</code> concept matches a dimension of either a base or derived quantity:</p> <ul> <li>Base dimensions are explicitly defined by a user   by inheriting from the instantiation of a <code>base_dimension</code> class template. It should be instantiated with   a unique symbol identifier describing this dimension in a specific   system of quantities.</li> <li>Derived dimensions are implicitly created   by the library's framework based on the quantity equation   provided in the quantity specification.</li> </ul> Examples <p><code>isq::dim_length</code>, <code>isq::dim_mass</code>, <code>isq::dim_time</code>, <code>isq::dim_electric_current</code>, <code>isq::dim_thermodynamic_temperature</code>, <code>isq::dim_amount_of_substance</code>, and <code>isq::dim_luminous_intensity</code> are the dimensions of base quantities in the ISQ.</p> <p>IEC 80000 provides <code>iec80000::dim_traffic_intensity</code> base dimension to extend ISQ with information technology quantities.</p> <p><code>derived_dimension&lt;isq::dim_length, per&lt;isq::dim_time&gt;&gt;</code> is a resulting dimension of <code>isq::dim_length / isq::dim_time</code>.</p> <p>A <code>Dimension</code> can be defined by the user in the following way:</p> <pre><code>inline constexpr struct dim_length : base_dimension&lt;\"L\"&gt; {} dim_length;\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#quantityspec","title":"<code>QuantitySpec</code>","text":"<p><code>QuantitySpec</code> concept matches all the quantity specifications including:</p> <ul> <li>Base quantities defined by a user by inheriting from   the <code>quantity_spec</code> class template instantiated with a base dimension   argument.</li> <li>Derived named quantities defined by a user by   inheriting from the <code>quantity_spec</code> class template instantiated with a result of a   quantity equation passed as an argument.</li> <li>Other named quantities forming a hierarchy of quantities   of the same kind defined by a user by inheriting from the   <code>quantity_spec</code> class template instantiated with another \"parent\" quantity specification passed as an   argument.</li> <li>Quantity kinds describing a family of mutually comparable quantities.</li> <li>Intermediate derived quantity specifications being   a result of a quantity equations on other specifications.</li> </ul> Examples <p><code>isq::length</code>, <code>isq::mass</code>, <code>isq::time</code>, <code>isq::electric_current</code>, <code>isq::thermodynamic_temperature</code>, <code>isq::amount_of_substance</code>, and <code>isq::luminous_intensity</code> are the specifications of base quantities in the ISQ.</p> <p><code>isq::width</code>, <code>isq::height</code>, <code>isq::radius</code>, and <code>isq::position_vector</code> are only a few of many quantities of a kind length specified in the ISQ.</p> <p><code>kind_of&lt;isq::length&gt;</code> behaves as any of the quantities of a kind length.</p> <p><code>isq::area</code>, <code>isq::speed</code>, <code>isq::moment_of_force</code> are only a few of many derived quantities provided in the ISQ.</p> <p><code>derived_quantity_spec&lt;isq::length, per&lt;isq::time&gt;&gt;</code> is a resulting quantity specification of <code>isq::length / isq::time</code>.</p> <p><code>QuantitySpec</code> can be defined by the user in one of the following ways:</p> <pre><code>inline constexpr struct length : quantity_spec&lt;dim_length&gt; {} length;\ninline constexpr struct height : quantity_spec&lt;length&gt; {} height;\ninline constexpr struct speed : quantity_spec&lt;length / time&gt; {} speed;\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#unit","title":"<code>Unit</code>","text":"<p><code>Unit</code> concept matches all the units in the library including:</p> <ul> <li>Base units defined by a user by inheriting from the <code>named_unit</code>   class template instantiated with a unique symbol identifier describing this unit in a specific   system of units.</li> <li>Named scaled units defined by a user by inheriting from the <code>named_unit</code> class template instantiated   with a unique symbol identifier and a product of multiplying another unit with some magnitude.</li> <li>Prefixed units defined by a user by inheriting from the <code>prefixed_unit</code> class template instantiated   with a magnitude and a unit to be prefixed.</li> <li>Derived named units defined by a user by inheriting from the   <code>named_unit</code> class template instantiated with a unique symbol identifier and a result of   unit equation passed as an argument.</li> <li>Derived unnamed units being a result of a   unit equations on other units.</li> </ul> <p>Note</p> <p>In the mp-units library, physical constants are also implemented as units.</p> Examples <p><code>si::second</code>, <code>si::metre</code>, <code>si::kilogram</code>, <code>si::ampere</code>, <code>si::kelvin</code>, <code>si::mole</code>, and <code>si::candela</code> are the base units of SI.</p> <p><code>si::kilo&lt;si::metre&gt;</code> is a prefixed unit on length.</p> <p><code>si::radian</code>, <code>si::newton</code>, and <code>si::watt</code> are examples of named derived quantities within SI.</p> <p><code>derived_unit&lt;si::metre, per&lt;si::second&gt;&gt;</code> is a resulting derived unit of <code>si::metre / si::second</code>.</p> <p><code>non_si::minute</code> is an example of a scaled unit of time.</p> <p><code>si::si2019::speed_of_light_in_vacuum</code> is a physical constant standardized by the SI in 2019.</p> <p><code>Unit</code> can be defined by the user in one of the following ways:</p> <pre><code>inline constexpr struct second : named_unit&lt;\"s\", kind_of&lt;isq::time&gt;&gt; {} second;\ninline constexpr struct gram : named_unit&lt;\"g\", kind_of&lt;isq::mass&gt;&gt; {} gram;\ninline constexpr struct minute : named_unit&lt;\"min\", mag&lt;60&gt; * second&gt; {} minute;\ninline constexpr struct kilogram : decltype(kilo&lt;gram&gt;) {} kilogram;\ninline constexpr struct newton : named_unit&lt;\"N\", kilogram * metre / square(second)&gt; {} newton;\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#associatedunit","title":"<code>AssociatedUnit</code>","text":"<p><code>AssociatedUnit</code> concept describes a unit with an associated quantity and is satisfied by:</p> <ul> <li>All units derived from a <code>named_unit</code> class template instantiated with a unique symbol identifier   and a <code>QuantitySpec</code>.</li> <li>All units being a result of a unit equations on other   associated units.</li> </ul> Examples <p>All units in the SI have associated quantities.</p> <p>Natural units typically do not have an associated quantity.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#prefixableunit","title":"<code>PrefixableUnit</code>","text":"<p><code>PrefixableUnit</code> concept is satisfied by all units derived from a <code>named_unit</code> class template for which a customization point <code>unit_can_be_prefixed&lt;U&gt;</code> was not explicitly set to <code>false</code>. Such units can be passed as an argument to a <code>prefixed_unit</code> class template.</p> Examples <p>All units in the SI can be prefixed with SI-defined prefixes.</p> <p>Some off-system units like <code>non_si::day</code> can't be prefixed.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#unitof","title":"<code>UnitOf&lt;QS&gt;</code>","text":"<p><code>UnitOf&lt;QS&gt;</code> concept is satisfied for all units matching an <code>AssociatedUnit</code> concept with an associated quantity type implicitly convertible to <code>QS</code>.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#reference","title":"<code>Reference</code>","text":"<p><code>Reference</code> concept is satisfied by all quantity reference types types. Such types provide all the meta-information required to create a <code>Quantity</code>. A <code>Reference</code> can be either:</p> <ul> <li>An AssociatedUnit</li> <li>The instantiation of a <code>reference</code> class template with a <code>QuantitySpec</code> passed as   the first template argument and a <code>Unit</code> passed as the second one.</li> </ul> Examples <p><code>si::metre</code> is defined in the SI as a unit of <code>isq::length</code> and thus can be used as a reference to instantiate a quantity of length.</p> <p>The expression <code>isq::height[m]</code> results with <code>reference&lt;isq::height, si::metre&gt;</code> which can be used to instantiate a quantity of <code>isq::height</code> with a unit of <code>si::metre</code>.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#referenceof","title":"<code>ReferenceOf&lt;V&gt;</code>","text":"<p><code>ReferenceOf&lt;V&gt;</code> concept is satisfied by references that match the following value <code>V</code>:</p> <code>V</code> Condition <code>Dimension</code> The dimension of a quantity specification is the same as <code>V</code> <code>QuantitySpec</code> The quantity specification is implicitly convertible to <code>V</code> <code>quantity_character</code> The quantity specification has a character of <code>V</code>"},{"location":"users_guide/framework_basics/basic_concepts/#representation","title":"<code>Representation</code>","text":"<p><code>Representation</code> concept constraints a type of a number that stores the value of a quantity.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#representationof","title":"<code>RepresentationOf&lt;Ch&gt;</code>","text":"<p><code>RepresentationOf&lt;Ch&gt;</code> concept is satisfied by all <code>Representation</code> types that are of a specified quantity character. A user can declare a custom representation type to be of a specific character by providing the specialization with <code>true</code> for one or more of the following variable templates:</p> <ul> <li><code>is_scalar&lt;T&gt;</code></li> <li><code>is_vector&lt;T&gt;</code></li> <li><code>is_tensor&lt;T&gt;</code></li> </ul>"},{"location":"users_guide/framework_basics/basic_concepts/#quantity","title":"<code>Quantity</code>","text":"<p><code>Quantity</code> concept matches every quantity in the library and is satisfied by all types being or deriving from and instantiation of a <code>quantity</code> class template.</p> Examples <p>All of <code>42 * m</code>, <code>42 * si::metre</code>, <code>42 * isq::height[m]</code> create a quantity and thus satisfy a <code>Quantity</code> concept.</p> <p>A quantity type can also be specified explicitly (i.e. <code>quantity&lt;si::metre, int&gt;</code>, <code>quantity&lt;isq::height[m]&gt;</code>).</p>"},{"location":"users_guide/framework_basics/basic_concepts/#quantityof","title":"<code>QuantityOf&lt;V&gt;</code>","text":"<p><code>QuantityOf&lt;V&gt;</code> concept is satisfied by all the quantities for which a <code>ReferenceOf&lt;V&gt;</code> is <code>true</code>.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#pointorigin","title":"<code>PointOrigin</code>","text":"<p><code>PointOrigin</code> concept matches all quantity point origins in the library. It is satisfied by either:</p> <ul> <li>Compile-time known <code>QuantityPoint</code></li> <li>All types derived from an <code>absolute_point_origin</code> class template.</li> </ul> Examples <p>The types of both definitions below satisfy a <code>PointOrigin</code> concept:</p> <pre><code>inline constexpr struct mean_sea_level : absolute_point_origin&lt;isq::height&gt; {} mean_sea_level;\ninline constexpr auto ice_point = quantity_point&lt;isq::thermodynamic_temperature[K]&gt;{273.15};\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#pointoriginfor","title":"<code>PointOriginFor&lt;QS&gt;</code>","text":"<p><code>PointOriginFor&lt;QS&gt;</code> concept is satisfied by all <code>PointOrigin</code> types that are defined using a provided quantity specification.</p>"},{"location":"users_guide/framework_basics/basic_concepts/#quantitypoint","title":"<code>QuantityPoint</code>","text":"<p><code>QuantityPoint</code> concept is satisfied by all types being either a specialization or derived from <code>quantity_point</code> class template.</p> Examples <p>The following specifies a quantity point defined in terms of an ice point provided in the previous example:</p> <pre><code>constexpr auto room_reference_temperature = quantity_point&lt;isq::Celsius_temperature[deg_C], ice_point&gt;{21};\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#quantitypointof","title":"<code>QuantityPointOf&lt;V&gt;</code>","text":"<p><code>QuantityPointOf&lt;V&gt;</code> concept is satisfied by all the quantity points for which either:</p> <ul> <li>a <code>ReferenceOf&lt;V&gt;</code> is <code>true</code>.</li> <li>the type of <code>V</code> satisfies <code>PointOrigin</code> concept and the quantity point's   absolute point origin is convertible to <code>V</code>.</li> </ul>"},{"location":"users_guide/framework_basics/basic_concepts/#interoperability-concepts","title":"Interoperability concepts","text":""},{"location":"users_guide/framework_basics/basic_concepts/#quantitylike","title":"<code>QuantityLike</code>","text":"<p><code>QuantityLike</code> concept is satisfied by a type <code>T</code> for which an instantiation of <code>quantity_like_traits</code> type trait yields a valid type that provides:</p> <ul> <li>static member <code>reference</code> that matches the <code>Reference</code> concept</li> <li><code>rep</code> type that matches <code>RepresentationOf</code> concept with the character provided   in <code>reference</code></li> <li><code>number(T)</code> static member function returning a type convertible to <code>rep</code></li> </ul> Examples <p>This is how support for <code>std::chrono::seconds</code> can be provided:</p> <pre><code>template&lt;&gt;\nstruct quantity_like_traits&lt;std::chrono::seconds&gt; {\nstatic constexpr auto reference = si::second;\nusing rep = std::chrono::seconds::rep;\n[[nodiscard]] static constexpr rep number(const std::chrono::seconds&amp; q) { return q.count(); }\n};\n</code></pre>"},{"location":"users_guide/framework_basics/basic_concepts/#quantitypointlike","title":"<code>QuantityPointLike</code>","text":"<p><code>QuantityPointLike</code> concept is satisfied by a type <code>T</code> for which an instantiation of <code>quantity_point_like_traits</code> type trait yields a valid type that provides:</p> <ul> <li>static member <code>reference</code> that matches the <code>Reference</code> concept</li> <li>static member <code>point_origin</code> that matches the <code>PointOrigin</code> concept</li> <li><code>rep</code> type that matches <code>RepresentationOf</code> concept with the character provided   in <code>reference</code></li> <li><code>relative(T)</code> static member function returning a type that can be used to construct   the <code>QuantityPoint</code> type</li> </ul> Examples <p>This is how support for a <code>std::chrono::time_point</code> of <code>std::chrono::seconds</code> can be provided:</p> <pre><code>template&lt;typename C&gt;\nstruct quantity_point_like_traits&lt;std::chrono::time_point&lt;C, std::chrono::seconds&gt;&gt; {\nstatic constexpr auto reference = si::second;\nstatic constexpr auto point_origin = absolute_point_origin&lt;isq::time&gt;;\nusing rep = Rep;\n[[nodiscard]] static constexpr auto relative(const std::chrono::time_point&lt;C, std::chrono::seconds&gt;&amp; qp)\n{\nreturn std::chrono::duration_cast&lt;std::chrono::seconds&gt;(qp.time_since_epoch());\n}\n};\n</code></pre>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/","title":"Simple and Typed Quantities","text":"<p>ISO specifies a quantity as:</p> <p>Quote</p> <p>property of a phenomenon, body, or substance, where the property has a magnitude that can be expressed as a number and a reference</p> <p>After that, it says:</p> <p>Quote</p> <p>A reference can be a measurement unit, a measurement procedure, a reference material, or a combination of such.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#quantity-class-template","title":"<code>quantity</code> class template","text":"<p>In the mp-units library, a quantity is represented with the following class template:</p> <pre><code>template&lt;Reference auto R,\nRepresentationOf&lt;get_quantity_spec(R).character&gt; Rep = double&gt;\nclass quantity;\n</code></pre> <p>The concept <code>Reference</code> is satisfied by either:</p> <ul> <li>a unit with an associated quantity type (i.e. <code>si::metre</code>)</li> <li>a reference type explicitly specifying the quantity type and its unit.</li> </ul> <p>Note</p> <p>All units in the SI system have an associated quantity type.</p> <p>A reference type is implicitly created as a result of the following expression:</p> <pre><code>constexpr auto ref = isq::length[m];\n</code></pre> <p>The above example resulted in the following type <code>reference&lt;isq::length(), si::metre()&gt;</code> being instantiated.</p> <p>Based on this property, the mp-units library provides two modes of dealing with quantities.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#simple-quantities","title":"Simple quantities","text":"<p>The simple mode might be preferred by many developers. It is all about units. Quantities using this mode have shorter type identifiers, resulting in easier-to-understand error messages and better debugging experience.</p> <p>Here is a simple example showing how to deal with such quantities:</p> <pre><code>#include &lt;mp-units/iostream.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;iostream&gt;\nusing namespace mp_units;\nconstexpr quantity&lt;si::metre / si::second&gt; avg_speed(quantity&lt;si::metre&gt; d,\nquantity&lt;si::second&gt; t)\n{\nreturn d / t;\n}\nint main()\n{\nusing namespace mp_units::si::unit_symbols;\nconst auto distance = 110 * km;\nconst auto duration = 2 * h;\nconst auto speed = avg_speed(distance, duration);\nstd::cout &lt;&lt; \"A car driving \" &lt;&lt; distance &lt;&lt; \" in \" &lt;&lt; duration\n&lt;&lt; \" has an average speed of \" &lt;&lt; speed\n&lt;&lt; \" (\" &lt;&lt; speed[km / h] &lt;&lt; \")\\n\";\n}\n</code></pre> <p>The code above prints:</p> <pre><code>A car driving 110 km in 2 h has an average speed of 15.2778 m/s (55 km/h)\n</code></pre> <p>Try it on Compiler Explorer</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#easy-to-understand-compilation-error-messages","title":"Easy to understand compilation error messages","text":"<p>In case a user makes an error in a quantity equation and the result of the calculation will not match the function return type, the compiler will detect such an issue at compile-time.</p> <p>For example, in case we will make the following error:</p> <pre><code>constexpr quantity&lt;si::metre / si::second&gt; avg_speed(quantity&lt;si::metre&gt; d,\nquantity&lt;si::second&gt; t)\n{\nreturn d * t;  // (1)!\n}\n</code></pre> <ol> <li>Quantities multiplied (instead of divided) by accident.</li> </ol> <p>the following compilation error message will be provided:</p> <pre><code>In function 'constexpr mp_units::quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::per&lt;mp_units::si::second&gt; &gt;()&gt; avg_speed(mp_units::quantity&lt;mp_units::si::metre()&gt;, mp_units::quantity&lt;mp_units::si::second()&gt;)':\nerror: could not convert 'mp_units::operator*&lt;si::metre(), double, si::second(), double&gt;(d, t)' from 'quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::si::second&gt;(),[...]&gt;' to 'quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::per&lt;mp_units::si::second&gt; &gt;(),[...]&gt;'\n   11 |   return d * t;\n      |          ~~^~~\n      |            |\n      |            quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::si::second&gt;(),[...]&gt;\n</code></pre>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#typed-quantities","title":"Typed quantities","text":"<p>Simple mode is all about and just about units. In case you care about a specific quantity type, typed quantities should be preferred. With this mode, for example, you can specify if you deal with <code>width</code>, <code>height</code>, or <code>radius</code> and ensure you will not assign one to another by accident.</p> <p>The previous example can be re-typed using typed quantities in the following way:</p> <pre><code>#include &lt;mp-units/iostream.h&gt;\n#include &lt;mp-units/systems/isq/space_and_time.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;iostream&gt;\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\nconstexpr quantity&lt;isq::speed[m / s]&gt; avg_speed(quantity&lt;isq::length[m]&gt; d,\nquantity&lt;isq::time[s]&gt; t)\n{\nreturn d / t;\n}\nint main()\n{\nconst auto distance = isq::distance(110 * km);\nconst auto duration = isq::time(2 * h);\nconst auto speed = avg_speed(distance, duration);\nstd::cout &lt;&lt; \"A car driving \" &lt;&lt; distance &lt;&lt; \" in \" &lt;&lt; duration\n&lt;&lt; \" has an average speed of \" &lt;&lt; speed\n&lt;&lt; \" (\" &lt;&lt; speed[km / h] &lt;&lt; \")\\n\";\n}\n</code></pre> <pre><code>A car driving 110 km in 2 h has an average speed of 15.2778 m/s (55 km/h)\n</code></pre> <p>Try it on Compiler Explorer</p> <p>In case we will accidentally make the same calculation error as before, this time, we will get a bit longer error message also containing information about the quantity type:</p> <pre><code>In function 'constexpr mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::speed(), mp_units::derived_unit&lt;mp_units::si::metre, mp_units::per&lt;mp_units::si::second&gt; &gt;()&gt;()&gt; avg_speed(mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::length(), mp_units::si::metre()&gt;()&gt;, mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::time(), mp_units::si::second()&gt;()&gt;)':\nerror: could not convert 'mp_units::operator*&lt;reference&lt;isq::length(), si::metre()&gt;(), double, reference&lt;isq::time(), si::second()&gt;(), double&gt;(d, t)' from 'quantity&lt;mp_units::reference&lt;mp_units::derived_quantity_spec&lt;mp_units::isq::length, mp_units::isq::time&gt;(), mp_units::derived_unit&lt;mp_units::si::metre, mp_units::si::second&gt;()&gt;(),[...]&gt;' to 'quantity&lt;mp_units::reference&lt;mp_units::isq::speed(), mp_units::derived_unit&lt;mp_units::si::metre, mp_units::per&lt;mp_units::si::second&gt; &gt;()&gt;(),[...]&gt;'\n   12 |   return d * t;\n      |          ~~^~~\n      |            |\n      |            quantity&lt;mp_units::reference&lt;mp_units::derived_quantity_spec&lt;mp_units::isq::length, mp_units::isq::time&gt;(), mp_units::derived_unit&lt;mp_units::si::metre, mp_units::si::second&gt;()&gt;(),[...]&gt;\n</code></pre> <p>As we can see above, the compilation error is longer but still relatively easy to understand.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#additional-type-safety-with-typed-quantities","title":"Additional type safety with typed quantities","text":"<p>Based on the previous example, it might seem that typed quantities are not that useful, more to type and provide harder-to-understand error messages. It might be true in some cases, but there are cases where they provide an additional level of safety.</p> <p>Let's see another example:</p> SimpleTyped <pre><code>#include &lt;mp-units/math.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;numbers&gt;\nusing namespace mp_units;\nclass StorageTank {\nquantity&lt;square(si::metre)&gt; base_;\nquantity&lt;si::metre&gt; height_;\npublic:\nconstexpr StorageTank(const quantity&lt;square(si::metre)&gt;&amp; base,\nconst quantity&lt;si::metre&gt;&amp; height) :\nbase_(base), height_(height)\n{\n}\n// ...\n};\nclass CylindricalStorageTank : public StorageTank {\npublic:\nconstexpr CylindricalStorageTank(const quantity&lt;si::metre&gt;&amp; radius,\nconst quantity&lt;si::metre&gt;&amp; height) :\nStorageTank(std::numbers::pi * pow&lt;2&gt;(radius), height)\n{\n}\n};\nclass RectangularStorageTank : public StorageTank {\npublic:\nconstexpr RectangularStorageTank(const quantity&lt;si::metre&gt;&amp; length,\nconst quantity&lt;si::metre&gt;&amp; width,\nconst quantity&lt;si::metre&gt;&amp; height) :\nStorageTank(length * width, height)\n{\n}\n};\nint main()\n{\nusing namespace mp_units::si::unit_symbols;\nauto tank = RectangularStorageTank(1'000 * mm, 500 * mm, 200 * mm);\n// ...\n}\n</code></pre> <pre><code>#include &lt;mp-units/math.h&gt;\n#include &lt;mp-units/systems/isq/space_and_time.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;numbers&gt;\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n// add a custom quantity type of kind isq::length\ninline constexpr struct horizontal_length\n: quantity_spec&lt;isq::length&gt; {} horizontal_length;\n// add a custom derived quantity type of kind isq::area\n// with a constrained quantity equation\ninline constexpr struct horizontal_area\n: quantity_spec&lt;isq::area, horizontal_length * isq::width&gt; {} horizontal_area;\nclass StorageTank {\nquantity&lt;horizontal_area[m2]&gt; base_;\nquantity&lt;isq::height[m]&gt; height_;\npublic:\nconstexpr StorageTank(const quantity&lt;horizontal_area[m2]&gt;&amp; base,\nconst quantity&lt;isq::height[m]&gt;&amp; height) :\nbase_(base), height_(height)\n{\n}\n// ...\n};\nclass CylindricalStorageTank : public StorageTank {\npublic:\nconstexpr CylindricalStorageTank(const quantity&lt;isq::radius[m]&gt;&amp; radius,\nconst quantity&lt;isq::height[m]&gt;&amp; height) :\nStorageTank(quantity_cast&lt;horizontal_area&gt;(std::numbers::pi * pow&lt;2&gt;(radius)),\nheight)\n{\n}\n};\nclass RectangularStorageTank : public StorageTank {\npublic:\nconstexpr RectangularStorageTank(const quantity&lt;horizontal_length[m]&gt;&amp; length,\nconst quantity&lt;isq::width[m]&gt;&amp; width,\nconst quantity&lt;isq::height[m]&gt;&amp; height) :\nStorageTank(length * width, height)\n{\n}\n};\nint main()\n{\nauto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\nisq::width(500 * mm),\nisq::height(200 * mm));\n// ...\n}\n</code></pre> <p>In the above example, the highlighted call doesn't look that safe anymore in the case of simple quantities, right? Suppose someone, either by mistake or due to some refactoring, will call the function with invalid order of arguments. In that case, the program will compile fine but not work as expected.</p> <p>Let's see what will happen if we reorder the arguments in the case of typed quantities:</p> <pre><code>auto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\nisq::height(200 * mm),\nisq::width(500 * mm));\n</code></pre> <p>This time a compiler provides the following compilation error:</p> <pre><code>In function 'int main()':\nerror: no matching function for call to 'RectangularStorageTank::RectangularStorageTank(mp_units::quantity&lt;mp_units::reference&lt;horizontal_length(), mp_units::si::milli_&lt;mp_units::si::metre()&gt;()&gt;(), int&gt;, mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::milli_&lt;mp_units::si::metre()&gt;()&gt;(), int&gt;, mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::width(), mp_units::si::milli_&lt;mp_units::si::metre()&gt;()&gt;(), int&gt;)'\n   47 |                                      isq::width(500 * mm));\n      |                                                          ^\nnote: candidate: 'constexpr RectangularStorageTank::RectangularStorageTank(const mp_units::quantity&lt;mp_units::reference&lt;horizontal_length(), mp_units::si::metre()&gt;()&gt;&amp;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::width(), mp_units::si::metre()&gt;()&gt;&amp;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::metre()&gt;()&gt;&amp;)'\n   35 |   constexpr RectangularStorageTank(const quantity&lt;horizontal_length[m]&gt;&amp; length,\n      |             ^~~~~~~~~~~~~~~~~~~~~~\nnote:   no known conversion for argument 2 from 'mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::milli_&lt;mp_units::si::metre()&gt;()&gt;(), int&gt;' to 'const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::width(), mp_units::si::metre()&gt;()&gt;&amp;'\n   36 |                                    const quantity&lt;isq::width[m]&gt;&amp; width,\n      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n</code></pre> <p>What about derived quantities? In the above example, you probably noticed that we also defined a custom <code>horizontal_area</code> quantity of kind <code>isq::area</code>. This quantity has the special property of being implicitly constructible only from the result of the multiplication of quantities of <code>horizontal_area</code> and <code>isq::width</code> or the ones that implicitly convert to them.</p> <p>Based on the above error message, we already know that a quantity of <code>isq::height</code> is not implicitly constructible to the quantity of <code>isq::width</code>. This property is transitively passed to derived quantities using them. If by accident, we will try to create a <code>StorageTank</code> base class in the following way:</p> <pre><code>class RectangularStorageTank : public StorageTank {\npublic:\nconstexpr RectangularStorageTank(const quantity&lt;horizontal_length[m]&gt;&amp; length,\nconst quantity&lt;isq::width[m]&gt;&amp; width,\nconst quantity&lt;isq::height[m]&gt;&amp; height) :\nStorageTank(length * height, height)\n{\n}\n};\n</code></pre> <p>we will again get a compilation error message like this one:</p> <pre><code>In constructor 'constexpr RectangularStorageTank::RectangularStorageTank(const mp_units::quantity&lt;mp_units::reference&lt;horizontal_length(), mp_units::si::metre()&gt;()&gt;&amp;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::width(), mp_units::si::metre()&gt;()&gt;&amp;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::metre()&gt;()&gt;&amp;)':\nerror: no matching function for call to 'StorageTank::StorageTank(mp_units::quantity&lt;mp_units::reference&lt;mp_units::derived_quantity_spec&lt;horizontal_length, mp_units::isq::height&gt;(), mp_units::derived_unit&lt;mp_units::power&lt;mp_units::si::metre, 2&gt; &gt;()&gt;(), double&gt;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::metre()&gt;()&gt;&amp;)'\n   39 |       StorageTank(length * height, height)\n      |                                          ^\nnote: candidate: 'constexpr StorageTank::StorageTank(const mp_units::quantity&lt;mp_units::reference&lt;horizontal_area(), mp_units::derived_unit&lt;mp_units::power&lt;mp_units::si::metre, 2&gt; &gt;()&gt;()&gt;&amp;, const mp_units::quantity&lt;mp_units::reference&lt;mp_units::isq::height(), mp_units::si::metre()&gt;()&gt;&amp;)'\n   16 |   constexpr StorageTank(const quantity&lt;horizontal_area[m2]&gt;&amp; base,\n      |             ^~~~~~~~~~~\n&lt;source&gt;:16:62: note:   no known conversion for argument 1 from 'mp_units::quantity&lt;mp_units::reference&lt;mp_units::derived_quantity_spec&lt;horizontal_length, mp_units::isq::height&gt;(), mp_units::derived_unit&lt;mp_units::power&lt;mp_units::si::metre, 2&gt; &gt;()&gt;(), double&gt;' to 'const mp_units::quantity&lt;mp_units::reference&lt;horizontal_area(), mp_units::derived_unit&lt;mp_units::power&lt;mp_units::si::metre, 2&gt; &gt;()&gt;()&gt;&amp;'\n   16 |   constexpr StorageTank(const quantity&lt;horizontal_area[m2]&gt;&amp; base,\n      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n</code></pre> <p>Tip</p> <p>If you need to use various quantities of the same kind, consider using typed quantities to bring an additional level of safety to your project.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#quantity_cast-to-force-unsafe-conversions","title":"<code>quantity_cast()</code> to force unsafe conversions","text":"<p>Did you notice the <code>quantity_cast()</code> usage in the other child class?</p> <pre><code>class CylindricalStorageTank : public StorageTank {\npublic:\nconstexpr CylindricalStorageTank(const quantity&lt;isq::radius[m]&gt;&amp; radius,\nconst quantity&lt;isq::height[m]&gt;&amp; height) :\nStorageTank(quantity_cast&lt;horizontal_area&gt;(std::numbers::pi * pow&lt;2&gt;(radius)),\nheight)\n{\n}\n};\n</code></pre> <p>As <code>isq::radius</code> is not convertible to either a <code>horizontal_length</code> or <code>isq::width</code>, the derived quantity of <code>pow&lt;2&gt;(radius)</code> can't be converted to <code>horizontal_area</code> as well. It would be unsafe to allow such a conversion as not all of the circles lie flat on the ground, right?</p> <p>In such a case, the user has to explicitly force such an unsafe conversion with the help of a <code>quantity_cast()</code>. This function name is easy to spot in code reviews or while searching the project for problems if something goes sideways. In case of unexpected issues related to quantities, this should be the first function to look for.</p> <p>Tip</p> <p>Do not overuse <code>quantity_cast()</code>. Use it only when necessary and ensure that the requested conversion is exactly what you need in this case.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#which-mode-to-use-in-my-project","title":"Which mode to use in my project?","text":"<p>In case you wonder which mode you should choose for your project, we have good news for you. Simple and typed quantity modes can be freely mixed with each other. When you use different quantities of the same kind (i.e. radius, wavelength, altitude, ...), you should probably reach for typed quantities to bring additional safety for those cases. Otherwise, just use simple mode for the remaining quantities. The mp-units library will do its best to protect your project based on the information provided.</p> <p>Tip</p> <p>You can easily mix simple and typed quantities in your project.</p>"},{"location":"users_guide/framework_basics/value_conversions/","title":"Value Conversions","text":""},{"location":"users_guide/framework_basics/value_conversions/#value-preserving-conversions","title":"Value-preserving conversions","text":"<pre><code>auto q1 = 5 * km;\nstd::cout &lt;&lt; q1[m] &lt;&lt; '\\n';\nquantity&lt;si::metre, int&gt; q2 = q1;\n</code></pre> <p>The second line above converts the current quantity to the one expressed in metres and prints its contents. The third line converts the quantity expressed in kilometres into the one measured in metres.</p> <p>Note</p> <p>It is always assumed that one can convert a quantity into another one with a unit of a higher resolution. There is no protection against overflow of the representation type. In case the target quantity ends up with a value bigger than the representation type can handle, you will be facing Undefined Behavior.</p> <p>In case a user would like to perform an opposite transformation:</p> <pre><code>auto q1 = 5 * m;\nstd::cout &lt;&lt; q1[km] &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;, int&gt; q2 = q1;\n</code></pre> <p>Both conversions will fail to compile.</p> <p>There are two ways to make the above work. The first solution is to use a floating-point representation type:</p> <pre><code>auto q1 = 5. * m;\nstd::cout &lt;&lt; q1[km] &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;&gt; q2 = q1;\n</code></pre> <p>The mp-units library follows <code>std::chrono::duration</code> logic and treats floating-point types as value-preserving.</p>"},{"location":"users_guide/framework_basics/value_conversions/#value-truncating-conversions","title":"Value-truncating conversions","text":"<p>The second solution is to force a truncating conversion:</p> <pre><code>auto q1 = 5 * m;\nstd::cout &lt;&lt; value_cast&lt;km&gt;(q1) &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;, int&gt; q2 = value_cast&lt;km&gt;(q1);\n</code></pre> <p>This explicit cast makes it clear that something unsafe is going on. It is easy to spot in code reviews or while chasing a bug in the source code.</p> <p>Another place where this cast is useful is when a user wants to convert a quantity with a floating-point representation to the one using an integral one. Again this is a truncating conversion, so an explicit cast is needed:</p> <pre><code>quantity&lt;si::metre, int&gt; q3 = value_cast&lt;int&gt;(3.14 * m);\n</code></pre> <p>Info</p> <p>It is often fine to use an integral as a representation type, but in general, floating-point types provide better precision and are privileged in the library as they are considered to be value-preserving.</p>"}]}